<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Kotlin on EricLog</title><link>https://eric.swiftzer.net/tags/kotlin/</link><description>Recent content in Kotlin on EricLog</description><generator>Hugo -- 0.141.0</generator><language>zh-tw</language><lastBuildDate>Sat, 14 Nov 2020 18:52:34 +0800</lastBuildDate><atom:link href="https://eric.swiftzer.net/tags/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Jetpack DataStore 搭配 kotlinx.serialization Protobuf</title><link>https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/</link><pubDate>Sat, 14 Nov 2020 18:52:34 +0800</pubDate><guid>https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/</guid><description>&lt;p>上月 &lt;a href="https://github.com/Kotlin/kotlinx.serialization">kotlinx.serialization&lt;/a> &lt;a href="https://blog.jetbrains.com/kotlin/2020/10/kotlinx-serialization-1-0-released/">出了 1.0 版&lt;/a>。除了支援 JSON 之外，還有支援 &lt;a href="https://developers.google.com/protocol-buffers">Protocol Buffers (Protobuf)&lt;/a>，而且還是跨平台支援。而在前一個月 Android 出了 &lt;a href="https://developer.android.com/topic/libraries/architecture/datastore">Jetpack DataStore&lt;/a>，它是一個用來取代 &lt;code>SharedPreferences&lt;/code> 的 library。它有兩種用法：&lt;/p></description></item><item><title>Kotlin Annotation Processor</title><link>https://eric.swiftzer.net/2020/04/kotlin-annotation-processor/</link><pubDate>Mon, 27 Apr 2020 23:34:08 +0800</pubDate><guid>https://eric.swiftzer.net/2020/04/kotlin-annotation-processor/</guid><description>&lt;p>如果有做過 Android 開發的話應該都有用過 annotation processor（又稱 codegen），即是在 &lt;em>build.gradle&lt;/em> 入面要用 &lt;code>annotationProcessor&lt;/code> 或者 &lt;code>kapt&lt;/code> 的那些 dependency。用法大概是在 code 上加上一些 &lt;code>@&lt;/code> 開頭的 annotation，然後 build 出來就會自動幫你生成相關的 class。簡單來說 annotation processor 就是用 code 來讓 Java compiler 生成 code。通常都是用來生成一些內容重覆的 code 來代替自己人手寫。&lt;/p></description></item><item><title>Kotlin Parcelize</title><link>https://eric.swiftzer.net/2018/02/parcelize/</link><pubDate>Sun, 11 Feb 2018 23:28:05 +0800</pubDate><guid>https://eric.swiftzer.net/2018/02/parcelize/</guid><description>&lt;p>&lt;a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">Kotlin Android extensions&lt;/a> 入面有一個實驗功能：Parcelize。它是一個 annotation，只需要在 &lt;a href="https://kotlinlang.org/docs/reference/data-classes.html">data class&lt;/a> 加上 &lt;code>@Parcelize&lt;/code> annotation 和 implement &lt;code>Parcelable&lt;/code> interface 就能夠在 compile 時自動生成所需的 boilerplate。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Parcelize&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Product&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Double&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Parcelable&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>留意要在 build.gradle 加上：&lt;/p></description></item><item><title>Parcelable &amp; Intent extra</title><link>https://eric.swiftzer.net/2017/09/parcelable-intent-extra/</link><pubDate>Sat, 16 Sep 2017 12:03:49 +0800</pubDate><guid>https://eric.swiftzer.net/2017/09/parcelable-intent-extra/</guid><description>&lt;p>Android 如果想將自己寫的 data type 的 object 傳到其他 &lt;code>Activity&lt;/code>、&lt;code>Fragment&lt;/code> 之類的地方的話，就要用 &lt;a href="https://developer.android.com/reference/android/os/Parcelable.html">&lt;code>Parcelable&lt;/code>&lt;/a> 來做 serialization/deserialization。&lt;code>Parcelable&lt;/code> 有點像 Java 本身的 &lt;code>Serializable&lt;/code>，不過 &lt;code>Parcelable&lt;/code> 是 Android SDK 內專為 Android 而特設的，所以會快過 &lt;code>Serializable&lt;/code>。&lt;/p></description></item><item><title>SemVer</title><link>https://eric.swiftzer.net/2017/06/semver/</link><pubDate>Fri, 16 Jun 2017 00:59:11 +0800</pubDate><guid>https://eric.swiftzer.net/2017/06/semver/</guid><description>&lt;p>剛剛為了方便做 force update app 功能的版本號碼比對就寫了一個 &lt;a href="http://semver.org/">Semantic Versioning (SemVer)&lt;/a> 的 Kotlin data class。這個 class 有 implement &lt;code>Comparable&lt;/code>，是參照 SemVer 規範要比對 major、minor、patch 和 pre-release version，但 &lt;code>equals&lt;/code> 就會再比對 build metadata（即是 Kotlin data class 的預設做法）。&lt;/p></description></item><item><title>Kotlin for Android</title><link>https://eric.swiftzer.net/2017/06/kotlin-for-android/</link><pubDate>Mon, 12 Jun 2017 23:43:16 +0800</pubDate><guid>https://eric.swiftzer.net/2017/06/kotlin-for-android/</guid><description>&lt;p>在四月開始轉用 &lt;a href="https://kotlinlang.org/">Kotlin&lt;/a> 來寫自己的 Android app。其實上年八月左右已經留意到 Kotlin 這個 JVM 語言能在 Android app 開發時使用，不過那時因為沒有太多時間所以只是看了少許官方教學和一些外國網誌就作罷，沒有真正拿來寫 Android app。到了最近看到愈來愈多人開始轉用 Kotlin 所以才真正開始轉用。到了現在 Kotlin 更成為 Android first-class support language。&lt;/p></description></item><item><title>Timber live template for Java/Kotlin</title><link>https://eric.swiftzer.net/2017/05/timber-live-template/</link><pubDate>Mon, 22 May 2017 22:53:34 +0800</pubDate><guid>https://eric.swiftzer.net/2017/05/timber-live-template/</guid><description>&lt;p>最近轉了用 &lt;a href="https://kotlinlang.org/">Kotlin&lt;/a> 來寫自己的 Android app，但發現 Android Studio 在 Kotlin 檔案內無法使用 Logcat &lt;code>logd&lt;/code>、&lt;code>logm&lt;/code> 之類的 &lt;a href="https://www.jetbrains.com/help/idea/using-live-templates.html">Live template&lt;/a>。&lt;a href="https://github.com/Kotlin/anko">Anko&lt;/a> 的 &lt;code>AnkoLogger&lt;/code> 因為用了 &lt;a href="https://developer.android.com/reference/android/util/Log.html#isLoggable%28java.lang.String,%20int%29">&lt;code>Log.isLoggable&lt;/code>&lt;/a> 來包住 &lt;code>Log.d&lt;/code> 之類的 method 所以在開發時看 log 不夠方便。於是就轉了用 &lt;a href="https://github.com/JakeWharton/timber">Timber&lt;/a> 來做 logging。但是轉了 logging library 都是沒有方便的方法來產生 log message。所以最後我參考了 Android Studio 的 log live template 來做了適用於 Java 和 Kotlin 的 Timber live template。&lt;/p></description></item><item><title>Spek</title><link>https://eric.swiftzer.net/2017/04/spek/</link><pubDate>Sat, 22 Apr 2017 23:25:52 +0800</pubDate><guid>https://eric.swiftzer.net/2017/04/spek/</guid><description>&lt;p>之前一直都有留意 &lt;a href="https://kotlinlang.org/">Kotlin&lt;/a> 這個程式語言在 Android app 開發的應用。最近試用 &lt;a href="http://spekframework.org/">Spek&lt;/a> 來做 Android project 的 local test。Spek 是一個用 Kotlin 寫的 testing framework，用法和 Ruby 的 &lt;a href="http://rspec.info/">RSpec&lt;/a> 差不多。對比 Android project 預設用的 JUnit 4，Spek 的寫法會比較清楚。因為 JUnit 4 只靠 class 和method 來為 test 分類，不能 nested（JUnit 5 才支援）。Spek 就用 nested 的方式來把 test 分類，還有就是用 string 來定義 test 名，比起 JUnit 4 用 method 名較易閱讀。&lt;/p>
&lt;p>Spek 有提供 &lt;a href="https://plugins.jetbrains.com/plugin/8564-spek">IntelliJ IDEA/Android Studio plugin&lt;/a>，而且還有 JUnit platform engine。所以在 Android project 上面使用都沒有太大問題。&lt;/p></description></item></channel></rss>