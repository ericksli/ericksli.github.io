<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin Annotation Processor | EricLog</title><meta name=keywords content="Kotlin"><meta name=description content="如果有做過 Android 開發的話應該都有用過 annotation processor（又稱 codegen），即是在 build.gradle 入面要用 annotationProcessor 或者 kapt 的那些 dependency。用法大概是在"><meta name=author content><link rel=canonical href=https://eric.swiftzer.net/2020/04/kotlin-annotation-processor/><link crossorigin=anonymous href=/assets/css/stylesheet.min.249b1770ac429c01ffa746cc012a310192d174c913b1527f312e3294a0766d1c.css integrity="sha256-JJsXcKxCnAH/p0bMASoxAZLRdMkTsVJ/MS4ylKB2bRw=" rel="preload stylesheet" as=style><link rel=icon href=https://eric.swiftzer.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://eric.swiftzer.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://eric.swiftzer.net/favicon-32x32.png><link rel=apple-touch-icon href=https://eric.swiftzer.net/apple-touch-icon.png><link rel=mask-icon href=https://eric.swiftzer.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@300&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-D93F946T73"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D93F946T73",{anonymize_ip:!1})}</script><meta property="og:title" content="Kotlin Annotation Processor"><meta property="og:description" content="如果有做過 Android 開發的話應該都有用過 annotation processor（又稱 codegen），即是在 build.gradle 入面要用 annotationProcessor 或者 kapt 的那些 dependency。用法大概是在"><meta property="og:type" content="article"><meta property="og:url" content="https://eric.swiftzer.net/2020/04/kotlin-annotation-processor/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-27T23:34:08+08:00"><meta property="article:modified_time" content="2020-04-27T23:34:08+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kotlin Annotation Processor"><meta name=twitter:description content="如果有做過 Android 開發的話應該都有用過 annotation processor（又稱 codegen），即是在 build.gradle 入面要用 annotationProcessor 或者 kapt 的那些 dependency。用法大概是在"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://eric.swiftzer.net/posts/"},{"@type":"ListItem","position":2,"name":"Kotlin Annotation Processor","item":"https://eric.swiftzer.net/2020/04/kotlin-annotation-processor/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin Annotation Processor","name":"Kotlin Annotation Processor","description":"如果有做過 Android 開發的話應該都有用過 annotation processor（又稱 codegen），即是在 build.gradle 入面要用 annotationProcessor 或者 kapt 的那些 dependency。用法大概是在","keywords":["Kotlin"],"articleBody":"如果有做過 Android 開發的話應該都有用過 annotation processor（又稱 codegen），即是在 build.gradle 入面要用 annotationProcessor 或者 kapt 的那些 dependency。用法大概是在 code 上加上一些 @ 開頭的 annotation，然後 build 出來就會自動幫你生成相關的 class。簡單來說 annotation processor 就是用 code 來讓 Java compiler 生成 code。通常都是用來生成一些內容重覆的 code 來代替自己人手寫。\n自己做一個功能不多的 annotation processor 其實都不太難。難的地方是 debug 時不能像平常般加 breakpoint，加上我們要生成 Kotlin class 所以跟平常找到的教學會有輕微出入（因為大部分教學都是討論生成 Java class）。\n這篇文章會示範做一個生成 feature flag 的 class。這個 feature flag 其實就是一個 interface，入面有不同的 method，一個 method 代表一個 feature flag，它們都是會回傳 boolean。把它做成 interface 而不直接定義一堆 boolean constant 的原因是方便寫 test case。我們可以 mock 那個 interface 就能測試那個 flag 是開和關的情境。下面是一個 interface 例子：\npackage com.example.annotation import com.example.annotation.annotation.FeatureFlag import com.example.annotation.annotation.FeatureFlagGroup @FeatureFlagGroup interface MyFeatureFlagsB { @FeatureFlag(key = \"feature_b1\", defaultValue = false) fun featureB1(): Boolean @FeatureFlag(key = \"feature_b2\", defaultValue = false) fun featureB2(): Boolean } @FeatureFlagGroup 和 @FeatureFlag 是我們做的 annotation，我們會寫一個 annotation processor 來讀取這些被標注的 class 和 method，然後生成 implement 這個 interface 的 class。下面就是完成品：\npackage com.example.annotation.sample import javax.annotation.Generated import javax.inject.Inject import kotlin.Boolean import kotlin.String import kotlin.collections.Map /** * Concrete implementation of [MyFeatureFlagsB]. */ @Generated(value = [\"com.example.annotation.codegen.FeatureFlagCodegen\"]) class MyFeatureFlagsBImpl @Inject constructor() : MyFeatureFlagsB { override fun featureB1(): Boolean = false override fun featureB2(): Boolean = false companion object { /** * Default value map */ val defaultValues: Map\u003cString, Boolean\u003e = mapOf( \"feature_b1\" to false, \"feature_b2\" to false ) } } 要做一個 annotation processor，我們要準備三個 module：\n放 annotation（@FeatureFlagGroup 和 @FeatureFlag）的 module (:annotation) 放 annotation processor 的 module (:codegen) 試用那個 annotation processor 的 module，這個會用到上面兩個 module (:sample) 這三個 module 的內容 Annotation Module 下面就是剛才看到那兩個 annotation。FeatureFlagGroup 是放在 interface 的，所以 @Target 是 AnnotationTarget.CLASS；而 FeatureFlag 是放在那些 method，用來標註它的名稱和回傳值。所以 @Target 是 AnnotationTarget.FUNCTION。\npackage com.example.annotation.annotation @Retention(AnnotationRetention.SOURCE) @Target(AnnotationTarget.CLASS) @MustBeDocumented annotation class FeatureFlagGroup package com.example.annotation.annotation @Retention(AnnotationRetention.SOURCE) @Target(AnnotationTarget.FUNCTION) @MustBeDocumented annotation class FeatureFlag(val key: String, val defaultValue: Boolean) Codegen Module 這個是我們的戲玉。要寫一個 annotation processor，首先是要 extend javax.annotation.processing.AbstractProcessor。入面有三個 method 需要 override：\ngetSupportedAnnotationTypes：把這個 processor 用到的 annotation 名稱列舉出來，即是 FeatureFlagGroup::class.java.name 和 FeatureFlag::class.java.name。 getSupportedSourceVersion：回傳支援的 Java 版本。我們簡單些回傳 SourceVersion.latestSupported() 就算了。 process：最重要的地方，我們會在入面讀取 annotation 然後生成 Kotlin code。 在 override process method 之前，我們要在這個 process class 加上 @AutoService 和 @SupportedOptions 兩個 annotation。第一個是 AutoService Processor，這個 processor 會幫你自動生成 META-INF/services/javax.annotation.processing.Processor 檔案。這個檔案是做 annotation processor 一定要有的東西。你可以自己手動加，但最方便都是用 @AutoService。\n第二個 annotation @SupportedOptions 是用來標明我們會用 Kotlin annotation processing (kapt)。另外開了一個 KAPT_KOTLIN_GENERATED_OPTION_NAME constant 是因為另一個地方都會用到。\nprivate const val KAPT_KOTLIN_GENERATED_OPTION_NAME = \"kapt.kotlin.generated\" @AutoService(Processor::class) @SupportedOptions(KAPT_KOTLIN_GENERATED_OPTION_NAME) class FeatureFlagCodegen : AbstractProcessor() 之後 process 入面就是這樣：找出外層那個 @FeatureFlagGroup，然後在它的 class 入面找用了 @FeatureFlag 的 method，之後就交由 generateImpl 生成 implement feature flag interface 的 class。\noverride fun process(annotations: MutableSet\u003cout TypeElement\u003e, roundEnv: RoundEnvironment): Boolean { if (roundEnv.processingOver()) return false roundEnv.getElementsAnnotatedWith(FeatureFlagGroup::class.java) .filter { it.kind == ElementKind.INTERFACE } .forEach { featureFlagGroupElement -\u003e val featureFlagElements = featureFlagGroupElement.enclosedElements .filter { it.getAnnotation(FeatureFlag::class.java) != null \u0026\u0026 it.kind == ElementKind.METHOD } val packageName = processingEnv.elementUtils.getPackageOf(featureFlagGroupElement).toString() generateImpl(packageName, featureFlagGroupElement, featureFlagElements) } return roundEnv.getElementsAnnotatedWith(FeatureFlagGroup::class.java).any { it.kind == ElementKind.INTERFACE } } generateImpl 比較長，所以都是分開幾段貼出來。如果要看完整的 code 可以到文末找到 Gist。\n首先是一段檢查 kapt，如果沒有就出錯誤。這亦示範了輸出錯誤的方法。processingEnv.options[\"kapt.kotlin.generated\"] 放的就是我們要把 code 寫進去的目錄。放在這目錄的檔案之後會連同本身的 source code 一齊 compile。KAPT_KOTLIN_GENERATED_OPTION_NAME 是我們在開首所定義的 constant。在生成新的檔案前要先建立這個目錄。\nval generatedSourcesRoot = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME].orEmpty() if (generatedSourcesRoot.isEmpty()) { processingEnv.messager.printMessage( Diagnostic.Kind.ERROR, \"Can't find the target directory for generated Kotlin files.\" ) return } val implClassName = \"${featureFlagGroupElement.simpleName}Impl\" val file = File(generatedSourcesRoot) file.mkdir() 之後我們就正式開始生成 code 了。簡單來說我們就是寫一個 program 來把一些 Kotlin source code 寫入到剛才那個目錄。雖然 Kotlin 有 \"\"\" 那款 raw string，亦都有 string template，但還是用 KotlinPoet 比較方便。如果是寫 Java 的話可以用 JavaPoet。\n下面我們直接看生成 class 的骨架，之後會補回未提及的 code block。\nFileSpec.builder(packageName, implClassName) .addType( TypeSpec.classBuilder(implClassName) .addAnnotation( AnnotationSpec.builder(Generated::class.java) .addMember(\"value = [%S]\", FeatureFlagCodegen::class.java.name) .build() ) .addKdoc(CodeBlock.of(\"Concrete implementation of [%T].\", className)) .primaryConstructor( FunSpec.constructorBuilder() .addAnnotation(ClassName(\"javax.inject\", \"Inject\")) .build() ) .addSuperinterface(className) .addFunctions(funSpecs) .addType( TypeSpec.companionObjectBuilder(null) .addProperty( PropertySpec.builder( \"defaultValues\", Map::class.asClassName() .parameterizedBy(String::class.asClassName(), Boolean::class.asClassName()) ) .initializer(defaultValuesMapCodeBlock) .addKdoc(\"Default value map\") .build() ) .build() ) .build() ) .build() .writeTo(file) 首先是看到 FileSpec.builder 然後才看到 TypeSpec.classBuilder。因為 Kotlin 是可以一個 .kt 檔案內包含多於一個 class。\n緊接 TypeSpec.classBuilder 是 addAnnotation。我們會在這個 class 加上 @Generated，讓人知道這個 class 是自動生成出來而不是人手寫的。不過留意的是，加了這個 annotation 不代表 JaCoCo 能自動忽略這個 class，因為 javax.annotation.Generated 的 retention policy 是 SOURCE，被 JaCoCo 看到之前這個 annotation 已被抽走。如果想被 JaCoCo 忽略的話還是要另外做一個 retention policy 是 RUNTIME 或 CLASS 的 @Generated annotation。\n接着就替這個 class 加上 KDoc（即是 Kotlin 寫 comment 的格式，類似 JavaDoc）。我們會用到 KotlinPoet 的 CodeBlock。CodeBlock 是一個 KotlinPoet 經常用到的東西，這是用來寫一句句 statement 用的。留心看的話會見到入面有個 %T，看起來好像平時 String.format 用到的 formatter。但其實這是 KotlinPoet 專用的 formatter。%T 就是代表 Type。KotlinPoet 能自動幫你生成對應的 import statement。下面是 className 的內容（就是透過 annotation 來取得被標註的 interface 名稱）：\nval className = ClassName( (featureFlagGroupElement.enclosingElement as PackageElement).qualifiedName.toString(), featureFlagGroupElement.simpleName.toString() ) 之後就開始寫 default constructor。這個 constructor 沒有任何參數，但要加上 @Inject annotation。由於這個 codegen module 沒有加到 javax.inject，所以我們直接寫它的全名。如果 codegen module 有加到 javax.inject 的話，那就可以寫成 addAnnotation(Inject::class.java)。但其實 codegen module 是不用加生成出來的 code 會用到的 dependency，只要知道它們全名就可以了。最重要的是用 codegen 那個 module 要加入這些 dependency。\n加了 default constructor 之後就是幫這個生成的 class 標明 superclass。就是用 addSuperinterface(className) 這一句。\n現在來到另一個主要的部分：addFunctions(funSpecs)。這句就是為這個 class 加入那些回傳 boolean (@FeatureFlag) 的 method。我們會用 FunSpec.overriding 來造這些 method。每個 method 入面都只有一句 return statement。Boolean 的值我們可以從 @FeatureFlag 的 defaultValue 找到。由於 Kotlin string template 可以直接輸出 boolean 的 true/false 字串，所以不需要用到那些特別的 formatter。\nval funSpecs = featureFlagElements.map { val executableElement = it as ExecutableElement val featureFlagAnnotation = it.getAnnotation(FeatureFlag::class.java) FunSpec.overriding(executableElement) .addStatement(\"return ${featureFlagAnnotation.defaultValue}\") .build() } 基本上來到這裏就大致完成了我們的 annotation processor。不過我們做一些特別的東西：加上 companion object 並加上一個名為 defaultValues 的 Map，用來放那個 feature flag 的名稱和它們的值。\nTypeSpec.companionObjectBuilder(null) .addProperty( PropertySpec.builder( \"defaultValues\", Map::class.asClassName() .parameterizedBy(String::class.asClassName(), Boolean::class.asClassName()) ) .initializer(defaultValuesMapCodeBlock) .addKdoc(\"Default value map\") .build() ) .build() defaultValuesMapCodeBlock 就是 mapOf(\"key1\" to true, \"key2\" to false) 那一句。\nCodeBlock 除了先前看到的 CodeBlock.of 外，𨗢有 builder 這種用法。%S 是 string 的意思，不用我們自己人手加 \"，讓 KotlinPoet 做就行了，自己做容易做錯。另外，to 的前後都有一個點 (·)。這亦都是 KotlinPoet 特別的字符。KotlinPoet 為了生成易讀的 code，它會自動斷行而不會一直把 code 寫成一行。但它有機會在不適當的地方斷行導致不能 compile。為避免它在 to 前後斷行，我們用 · 取代空白字元。\nval defaultValuesMapCodeBlock = featureFlagElements.foldIndexed(CodeBlock.builder().add(\"mapOf(\\n\")) { index, builder, element -\u003e val featureFlagAnnotation = element.getAnnotation(FeatureFlag::class.java) builder.add(\"%S·to·${featureFlagAnnotation.defaultValue}\", featureFlagAnnotation.key) if (index \u003c featureFlagElements.size - 1) { builder.add(\",\\n\") } else { builder.add(\"\\n)\") } builder }.build() Sample Module 現在可以來看看它的效果。完整的 code 可以在 Gist 找到。\n測試用的 Main、interface class 和生成的 class 參考 Annotation Processing 101 Java 注解处理 (Annotation Processor)：（三）代码生成 ","wordCount":"3100","inLanguage":"zh-tw","datePublished":"2020-04-27T23:34:08+08:00","dateModified":"2020-04-27T23:34:08+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://eric.swiftzer.net/2020/04/kotlin-annotation-processor/"},"publisher":{"@type":"Organization","name":"EricLog","logo":{"@type":"ImageObject","url":"https://eric.swiftzer.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://eric.swiftzer.net/ accesskey=h title="EricLog (Alt + H)">EricLog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://eric.swiftzer.net/fonts/ title=Fonts><span>Fonts</span></a></li><li><a href=https://eric.swiftzer.net/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://eric.swiftzer.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://eric.swiftzer.net/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://eric.swiftzer.net/>首頁</a>&nbsp;»&nbsp;<a href=https://eric.swiftzer.net/posts/>Posts</a></div><h1 class=post-title>Kotlin Annotation Processor</h1><div class=post-meta>April 27, 2020</div></header><div class=post-content><p>如果有做過 Android 開發的話應該都有用過 annotation processor（又稱 codegen），即是在 <em>build.gradle</em> 入面要用 <code>annotationProcessor</code> 或者 <code>kapt</code> 的那些 dependency。用法大概是在 code 上加上一些 <code>@</code> 開頭的 annotation，然後 build 出來就會自動幫你生成相關的 class。簡單來說 annotation processor 就是用 code 來讓 Java compiler 生成 code。通常都是用來生成一些內容重覆的 code 來代替自己人手寫。</p><p>自己做一個功能不多的 annotation processor 其實都不太難。難的地方是 debug 時不能像平常般加 breakpoint，加上我們要生成 Kotlin class 所以跟平常找到的教學會有輕微出入（因為大部分教學都是討論生成 Java class）。</p><p>這篇文章會示範做一個生成 feature flag 的 class。這個 feature flag 其實就是一個 interface，入面有不同的 method，一個 method 代表一個 feature flag，它們都是會回傳 boolean。把它做成 interface 而不直接定義一堆 boolean constant 的原因是方便寫 test case。我們可以 mock 那個 interface 就能測試那個 flag 是開和關的情境。下面是一個 interface 例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>package</span> <span class=nn>com.example.annotation</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>com.example.annotation.annotation.FeatureFlag</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>com.example.annotation.annotation.FeatureFlagGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@FeatureFlagGroup</span>
</span></span><span class=line><span class=cl><span class=k>interface</span> <span class=nc>MyFeatureFlagsB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@FeatureFlag</span><span class=p>(</span><span class=n>key</span> <span class=p>=</span> <span class=s2>&#34;feature_b1&#34;</span><span class=p>,</span> <span class=n>defaultValue</span> <span class=p>=</span> <span class=k>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>featureB1</span><span class=p>():</span> <span class=n>Boolean</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@FeatureFlag</span><span class=p>(</span><span class=n>key</span> <span class=p>=</span> <span class=s2>&#34;feature_b2&#34;</span><span class=p>,</span> <span class=n>defaultValue</span> <span class=p>=</span> <span class=k>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>featureB2</span><span class=p>():</span> <span class=n>Boolean</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p><code>@FeatureFlagGroup</code> 和 <code>@FeatureFlag</code> 是我們做的 annotation，我們會寫一個 annotation processor 來讀取這些被標注的 class 和 method，然後生成 implement 這個 interface 的 class。下面就是完成品：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>package</span> <span class=nn>com.example.annotation.sample</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>javax.annotation.Generated</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>javax.inject.Inject</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlin.Boolean</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlin.String</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlin.collections.Map</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Concrete implementation of [MyFeatureFlagsB].
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nd>@Generated</span><span class=p>(</span><span class=k>value</span> <span class=p>=</span> <span class=p>[</span><span class=s2>&#34;com.example.annotation.codegen.FeatureFlagCodegen&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyFeatureFlagsBImpl</span> <span class=nd>@Inject</span> <span class=k>constructor</span><span class=p>()</span> <span class=p>:</span> <span class=n>MyFeatureFlagsB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>fun</span> <span class=nf>featureB1</span><span class=p>():</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>override</span> <span class=k>fun</span> <span class=nf>featureB2</span><span class=p>():</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>companion</span> <span class=k>object</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Default value map
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>defaultValues</span><span class=p>:</span> <span class=n>Map</span><span class=p>&lt;</span><span class=n>String</span><span class=p>,</span> <span class=n>Boolean</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>mapOf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;feature_b1&#34;</span> <span class=n>to</span> <span class=k>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;feature_b2&#34;</span> <span class=n>to</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>要做一個 annotation processor，我們要準備三個 module：</p><ol><li>放 annotation（<code>@FeatureFlagGroup</code> 和 <code>@FeatureFlag</code>）的 module (<code>:annotation</code>)</li><li>放 annotation processor 的 module (<code>:codegen</code>)</li><li>試用那個 annotation processor 的 module，這個會用到上面兩個 module (<code>:sample</code>)</li></ol><figure><img loading=lazy src=project-structure.png><figcaption>這三個 module 的內容</figcaption></figure><h2 id=annotation-module>Annotation Module<a hidden class=anchor aria-hidden=true href=#annotation-module>#</a></h2><p>下面就是剛才看到那兩個 annotation。<code>FeatureFlagGroup</code> 是放在 interface 的，所以 <code>@Target</code> 是 <code>AnnotationTarget.CLASS</code>；而 <code>FeatureFlag</code> 是放在那些 method，用來標註它的名稱和回傳值。所以 <code>@Target</code> 是 <code>AnnotationTarget.FUNCTION</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>package</span> <span class=nn>com.example.annotation.annotation</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Retention</span><span class=p>(</span><span class=n>AnnotationRetention</span><span class=p>.</span><span class=n>SOURCE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nd>@Target</span><span class=p>(</span><span class=n>AnnotationTarget</span><span class=p>.</span><span class=n>CLASS</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nd>@MustBeDocumented</span>
</span></span><span class=line><span class=cl><span class=k>annotation</span> <span class=k>class</span> <span class=nc>FeatureFlagGroup</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>package</span> <span class=nn>com.example.annotation.annotation</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Retention</span><span class=p>(</span><span class=n>AnnotationRetention</span><span class=p>.</span><span class=n>SOURCE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nd>@Target</span><span class=p>(</span><span class=n>AnnotationTarget</span><span class=p>.</span><span class=n>FUNCTION</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nd>@MustBeDocumented</span>
</span></span><span class=line><span class=cl><span class=k>annotation</span> <span class=k>class</span> <span class=nc>FeatureFlag</span><span class=p>(</span><span class=k>val</span> <span class=py>key</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=k>val</span> <span class=py>defaultValue</span><span class=p>:</span> <span class=n>Boolean</span><span class=p>)</span></span></span></code></pre></div><h2 id=codegen-module>Codegen Module<a hidden class=anchor aria-hidden=true href=#codegen-module>#</a></h2><p>這個是我們的戲玉。要寫一個 annotation processor，首先是要 extend <code>javax.annotation.processing.AbstractProcessor</code>。入面有三個 method 需要 override：</p><ol><li><code>getSupportedAnnotationTypes</code>：把這個 processor 用到的 annotation 名稱列舉出來，即是 <code>FeatureFlagGroup::class.java.name</code> 和 <code>FeatureFlag::class.java.name</code>。</li><li><code>getSupportedSourceVersion</code>：回傳支援的 Java 版本。我們簡單些回傳 <code>SourceVersion.latestSupported()</code> 就算了。</li><li><code>process</code>：最重要的地方，我們會在入面讀取 annotation 然後生成 Kotlin code。</li></ol><p>在 override <code>process</code> method 之前，我們要在這個 process class 加上 <code>@AutoService</code> 和 <code>@SupportedOptions</code> 兩個 annotation。第一個是 <a href=https://github.com/google/auto/tree/master/service>AutoService Processor</a>，這個 processor 會幫你自動生成 <em>META-INF/services/javax.annotation.processing.Processor</em> 檔案。這個檔案是做 annotation processor 一定要有的東西。你可以自己手動加，但最方便都是用 <code>@AutoService</code>。</p><p>第二個 annotation <code>@SupportedOptions</code> 是用來標明我們會用 <a href=https://kotlinlang.org/docs/reference/kapt.html>Kotlin annotation processing (kapt)</a>。另外開了一個 <code>KAPT_KOTLIN_GENERATED_OPTION_NAME</code> constant 是因為另一個地方都會用到。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>private</span> <span class=k>const</span> <span class=k>val</span> <span class=py>KAPT</span><span class=n>_KOTLIN_GENERATED_OPTION_NAME</span> <span class=p>=</span> <span class=s2>&#34;kapt.kotlin.generated&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@AutoService</span><span class=p>(</span><span class=n>Processor</span><span class=o>::</span><span class=k>class</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nd>@SupportedOptions</span><span class=p>(</span><span class=n>KAPT_KOTLIN_GENERATED_OPTION_NAME</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FeatureFlagCodegen</span> <span class=p>:</span> <span class=n>AbstractProcessor</span><span class=p>()</span></span></span></code></pre></div><p>之後 <code>process</code> 入面就是這樣：找出外層那個 <code>@FeatureFlagGroup</code>，然後在它的 class 入面找用了 <code>@FeatureFlag</code> 的 method，之後就交由 <code>generateImpl</code> 生成 implement feature flag interface 的 class。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>process</span><span class=p>(</span><span class=n>annotations</span><span class=p>:</span> <span class=n>MutableSet</span><span class=p>&lt;</span><span class=k>out</span> <span class=n>TypeElement</span><span class=p>&gt;,</span> <span class=n>roundEnv</span><span class=p>:</span> <span class=n>RoundEnvironment</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>roundEnv</span><span class=p>.</span><span class=n>processingOver</span><span class=p>())</span> <span class=k>return</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>    <span class=n>roundEnv</span><span class=p>.</span><span class=n>getElementsAnnotatedWith</span><span class=p>(</span><span class=n>FeatureFlagGroup</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>filter</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>kind</span> <span class=o>==</span> <span class=n>ElementKind</span><span class=p>.</span><span class=n>INTERFACE</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>forEach</span> <span class=p>{</span> <span class=n>featureFlagGroupElement</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=k>val</span> <span class=py>featureFlagElements</span> <span class=p>=</span> <span class=n>featureFlagGroupElement</span><span class=p>.</span><span class=n>enclosedElements</span>
</span></span><span class=line><span class=cl>                <span class=p>.</span><span class=n>filter</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>getAnnotation</span><span class=p>(</span><span class=n>FeatureFlag</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span> <span class=o>!=</span> <span class=k>null</span> <span class=o>&amp;&amp;</span> <span class=k>it</span><span class=p>.</span><span class=n>kind</span> <span class=o>==</span> <span class=n>ElementKind</span><span class=p>.</span><span class=n>METHOD</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>val</span> <span class=py>packageName</span> <span class=p>=</span> <span class=n>processingEnv</span><span class=p>.</span><span class=n>elementUtils</span><span class=p>.</span><span class=n>getPackageOf</span><span class=p>(</span><span class=n>featureFlagGroupElement</span><span class=p>).</span><span class=n>toString</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>generateImpl</span><span class=p>(</span><span class=n>packageName</span><span class=p>,</span> <span class=n>featureFlagGroupElement</span><span class=p>,</span> <span class=n>featureFlagElements</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>roundEnv</span><span class=p>.</span><span class=n>getElementsAnnotatedWith</span><span class=p>(</span><span class=n>FeatureFlagGroup</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>).</span><span class=n>any</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>kind</span> <span class=o>==</span> <span class=n>ElementKind</span><span class=p>.</span><span class=n>INTERFACE</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><p><code>generateImpl</code> 比較長，所以都是分開幾段貼出來。如果要看完整的 code 可以到文末找到 Gist。</p><p>首先是一段檢查 <a href=https://kotlinlang.org/docs/reference/kapt.html>kapt</a>，如果沒有就出錯誤。這亦示範了輸出錯誤的方法。<code>processingEnv.options["kapt.kotlin.generated"]</code> 放的就是我們要把 code 寫進去的目錄。放在這目錄的檔案之後會連同本身的 source code 一齊 compile。<code>KAPT_KOTLIN_GENERATED_OPTION_NAME</code> 是我們在開首所定義的 constant。在生成新的檔案前要先建立這個目錄。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>generatedSourcesRoot</span> <span class=p>=</span> <span class=n>processingEnv</span><span class=p>.</span><span class=n>options</span><span class=p>[</span><span class=n>KAPT_KOTLIN_GENERATED_OPTION_NAME</span><span class=p>].</span><span class=n>orEmpty</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>generatedSourcesRoot</span><span class=p>.</span><span class=n>isEmpty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>processingEnv</span><span class=p>.</span><span class=n>messager</span><span class=p>.</span><span class=n>printMessage</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>Diagnostic</span><span class=p>.</span><span class=n>Kind</span><span class=p>.</span><span class=n>ERROR</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Can&#39;t find the target directory for generated Kotlin files.&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>implClassName</span> <span class=p>=</span> <span class=s2>&#34;</span><span class=si>${featureFlagGroupElement.simpleName}</span><span class=s2>Impl&#34;</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>file</span> <span class=p>=</span> <span class=n>File</span><span class=p>(</span><span class=n>generatedSourcesRoot</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>file</span><span class=p>.</span><span class=n>mkdir</span><span class=p>()</span></span></span></code></pre></div><p>之後我們就正式開始生成 code 了。簡單來說我們就是寫一個 program 來把一些 Kotlin source code 寫入到剛才那個目錄。雖然 Kotlin 有 <code>"""</code> 那款 <a href=https://kotlinlang.org/docs/reference/basic-types.html#string-literals>raw string</a>，亦都有 string template，但還是用 <a href=https://square.github.io/kotlinpoet/>KotlinPoet</a> 比較方便。如果是寫 Java 的話可以用 <a href=https://github.com/square/javapoet>JavaPoet</a>。</p><p>下面我們直接看生成 class 的骨架，之後會補回未提及的 code block。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>FileSpec</span><span class=p>.</span><span class=n>builder</span><span class=p>(</span><span class=n>packageName</span><span class=p>,</span> <span class=n>implClassName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>addType</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>TypeSpec</span><span class=p>.</span><span class=n>classBuilder</span><span class=p>(</span><span class=n>implClassName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>addAnnotation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>AnnotationSpec</span><span class=p>.</span><span class=n>builder</span><span class=p>(</span><span class=n>Generated</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>.</span><span class=n>addMember</span><span class=p>(</span><span class=s2>&#34;value = [%S]&#34;</span><span class=p>,</span> <span class=n>FeatureFlagCodegen</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>.</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>addKdoc</span><span class=p>(</span><span class=n>CodeBlock</span><span class=p>.</span><span class=n>of</span><span class=p>(</span><span class=s2>&#34;Concrete implementation of [%T].&#34;</span><span class=p>,</span> <span class=n>className</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>primaryConstructor</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>FunSpec</span><span class=p>.</span><span class=n>constructorBuilder</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=p>.</span><span class=n>addAnnotation</span><span class=p>(</span><span class=n>ClassName</span><span class=p>(</span><span class=s2>&#34;javax.inject&#34;</span><span class=p>,</span> <span class=s2>&#34;Inject&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>addSuperinterface</span><span class=p>(</span><span class=n>className</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>addFunctions</span><span class=p>(</span><span class=n>funSpecs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>addType</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>TypeSpec</span><span class=p>.</span><span class=n>companionObjectBuilder</span><span class=p>(</span><span class=k>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>.</span><span class=n>addProperty</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                        <span class=n>PropertySpec</span><span class=p>.</span><span class=n>builder</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                            <span class=s2>&#34;defaultValues&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=n>Map</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>asClassName</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                                <span class=p>.</span><span class=n>parameterizedBy</span><span class=p>(</span><span class=n>String</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>asClassName</span><span class=p>(),</span> <span class=n>Boolean</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>asClassName</span><span class=p>())</span>
</span></span><span class=line><span class=cl>                        <span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=p>.</span><span class=n>initializer</span><span class=p>(</span><span class=n>defaultValuesMapCodeBlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=p>.</span><span class=n>addKdoc</span><span class=p>(</span><span class=s2>&#34;Default value map&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>writeTo</span><span class=p>(</span><span class=k>file</span><span class=p>)</span></span></span></code></pre></div><p>首先是看到 <code>FileSpec.builder</code> 然後才看到 <code>TypeSpec.classBuilder</code>。因為 Kotlin 是可以一個 <em>.kt</em> 檔案內包含多於一個 class。</p><p>緊接 <code>TypeSpec.classBuilder</code> 是 <code>addAnnotation</code>。我們會在這個 class 加上 <a href=https://docs.oracle.com/javase/8/docs/api/javax/annotation/Generated.html><code>@Generated</code></a>，讓人知道這個 class 是自動生成出來而不是人手寫的。不過留意的是，<a href=https://github.com/jacoco/jacoco/issues/831>加了這個 annotation 不代表 JaCoCo 能自動忽略這個 class</a>，因為 <code>javax.annotation.Generated</code> 的 retention policy 是 <code>SOURCE</code>，被 JaCoCo 看到之前這個 annotation 已被抽走。如果想被 JaCoCo 忽略的話還是要另外做一個 retention policy 是 <code>RUNTIME</code> 或 <code>CLASS</code> 的 <code>@Generated</code> annotation。</p><p>接着就替這個 class 加上 <a href=https://kotlinlang.org/docs/reference/kotlin-doc.html>KDoc</a>（即是 Kotlin 寫 comment 的格式，類似 JavaDoc）。我們會用到 KotlinPoet 的 <code>CodeBlock</code>。<code>CodeBlock</code> 是一個 KotlinPoet 經常用到的東西，這是用來寫一句句 statement 用的。留心看的話會見到入面有個 <code>%T</code>，看起來好像平時 <code>String.format</code> 用到的 formatter。但其實這是 <a href=https://square.github.io/kotlinpoet/#t-for-types>KotlinPoet 專用的 formatter</a>。<code>%T</code> 就是代表 Type。KotlinPoet 能自動幫你生成對應的 <code>import</code> statement。下面是 <code>className</code> 的內容（就是透過 annotation 來取得被標註的 interface 名稱）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>className</span> <span class=p>=</span> <span class=n>ClassName</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>featureFlagGroupElement</span><span class=p>.</span><span class=n>enclosingElement</span> <span class=k>as</span> <span class=n>PackageElement</span><span class=p>).</span><span class=n>qualifiedName</span><span class=p>.</span><span class=n>toString</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>featureFlagGroupElement</span><span class=p>.</span><span class=n>simpleName</span><span class=p>.</span><span class=n>toString</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>)</span></span></span></code></pre></div><p>之後就開始寫 default constructor。這個 constructor 沒有任何參數，但要加上 <code>@Inject</code> annotation。由於這個 codegen module 沒有加到 javax.inject，所以我們直接寫它的全名。如果 codegen module 有加到 javax.inject 的話，那就可以寫成 <code>addAnnotation(Inject::class.java)</code>。但其實 codegen module 是不用加生成出來的 code 會用到的 dependency，只要知道它們全名就可以了。最重要的是用 codegen 那個 module 要加入這些 dependency。</p><p>加了 default constructor 之後就是幫這個生成的 class 標明 superclass。就是用 <code>addSuperinterface(className)</code> 這一句。</p><p>現在來到另一個主要的部分：<code>addFunctions(funSpecs)</code>。這句就是為這個 class 加入那些回傳 boolean (<code>@FeatureFlag</code>) 的 method。我們會用 <code>FunSpec.overriding</code> 來造這些 method。每個 method 入面都只有一句 return statement。Boolean 的值我們可以從 <code>@FeatureFlag</code> 的 <code>defaultValue</code> 找到。由於 Kotlin <a href=https://kotlinlang.org/docs/reference/basic-types.html#string-templates>string template</a> 可以直接輸出 boolean 的 <code>true</code>/<code>false</code> 字串，所以不需要用到那些特別的 formatter。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>funSpecs</span> <span class=p>=</span> <span class=n>featureFlagElements</span><span class=p>.</span><span class=n>map</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>executableElement</span> <span class=p>=</span> <span class=k>it</span> <span class=k>as</span> <span class=n>ExecutableElement</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>featureFlagAnnotation</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>getAnnotation</span><span class=p>(</span><span class=n>FeatureFlag</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>FunSpec</span><span class=p>.</span><span class=n>overriding</span><span class=p>(</span><span class=n>executableElement</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>addStatement</span><span class=p>(</span><span class=s2>&#34;return </span><span class=si>${featureFlagAnnotation.defaultValue}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>基本上來到這裏就大致完成了我們的 annotation processor。不過我們做一些特別的東西：加上 companion object 並加上一個名為 <code>defaultValues</code> 的 <code>Map&lt;String, Boolean></code>，用來放那個 feature flag 的名稱和它們的值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>TypeSpec</span><span class=p>.</span><span class=n>companionObjectBuilder</span><span class=p>(</span><span class=k>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>addProperty</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>PropertySpec</span><span class=p>.</span><span class=n>builder</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;defaultValues&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>Map</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>asClassName</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=p>.</span><span class=n>parameterizedBy</span><span class=p>(</span><span class=n>String</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>asClassName</span><span class=p>(),</span> <span class=n>Boolean</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>asClassName</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>initializer</span><span class=p>(</span><span class=n>defaultValuesMapCodeBlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>addKdoc</span><span class=p>(</span><span class=s2>&#34;Default value map&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>build</span><span class=p>()</span></span></span></code></pre></div><p><code>defaultValuesMapCodeBlock</code> 就是 <code>mapOf("key1" to true, "key2" to false)</code> 那一句。</p><p><code>CodeBlock</code> 除了先前看到的 <code>CodeBlock.of</code> 外，𨗢有 builder 這種用法。<a href=https://square.github.io/kotlinpoet/#s-for-strings><code>%S</code> 是 string 的意思</a>，不用我們自己人手加 <code>"</code>，讓 KotlinPoet 做就行了，自己做容易做錯。另外，<code>to</code> 的前後都有一個點 (<code>·</code>)。這亦都是 <a href=https://square.github.io/kotlinpoet/#spaces-wrap-by-default>KotlinPoet 特別的字符</a>。KotlinPoet 為了生成易讀的 code，它會自動斷行而不會一直把 code 寫成一行。但它有機會在不適當的地方斷行導致不能 compile。為避免它在 <code>to</code> 前後斷行，我們用 <code>·</code> 取代空白字元。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>defaultValuesMapCodeBlock</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>    <span class=n>featureFlagElements</span><span class=p>.</span><span class=n>foldIndexed</span><span class=p>(</span><span class=n>CodeBlock</span><span class=p>.</span><span class=n>builder</span><span class=p>().</span><span class=n>add</span><span class=p>(</span><span class=s2>&#34;mapOf(</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>))</span> <span class=p>{</span> <span class=n>index</span><span class=p>,</span> <span class=n>builder</span><span class=p>,</span> <span class=n>element</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>featureFlagAnnotation</span> <span class=p>=</span> <span class=n>element</span><span class=p>.</span><span class=n>getAnnotation</span><span class=p>(</span><span class=n>FeatureFlag</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>builder</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s2>&#34;%S·to·</span><span class=si>${featureFlagAnnotation.defaultValue}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>featureFlagAnnotation</span><span class=p>.</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=p>&lt;</span> <span class=n>featureFlagElements</span><span class=p>.</span><span class=n>size</span> <span class=p>-</span> <span class=m>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>builder</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s2>&#34;,</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>builder</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>builder</span>
</span></span><span class=line><span class=cl>    <span class=p>}.</span><span class=n>build</span><span class=p>()</span></span></span></code></pre></div><h2 id=sample-module>Sample Module<a hidden class=anchor aria-hidden=true href=#sample-module>#</a></h2><p>現在可以來看看它的效果。完整的 code 可以在 <a href=https://gist.github.com/ericksli/ea72dbb18884a4c0af6b758b54eccfc6>Gist</a> 找到。</p><figure><img loading=lazy src=sample-run.png><figcaption>測試用的 Main、interface class 和生成的 class</figcaption></figure><h2 id=參考>參考<a hidden class=anchor aria-hidden=true href=#參考>#</a></h2><ul><li><a href=http://hannesdorfmann.com/annotation-processing/annotationprocessing101>Annotation Processing 101</a></li><li><a href=https://blog.csdn.net/jjxojm/article/details/90349756>Java 注解处理 (Annotation Processor)：（三）代码生成</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://eric.swiftzer.net/tags/kotlin/>Kotlin</a></li></ul><nav class=paginav><a class=prev href=https://eric.swiftzer.net/2020/08/javax-measure/><span class=title>« 上一篇</span><br><span>Java 量度單位 (JSR 363 Units of Measurement API)</span></a>
<a class=next href=https://eric.swiftzer.net/2020/03/moshi-r8-parameter-type-is-null/><span class=title>下一篇 »</span><br><span>Moshi Kotlin Codegen + R8 出現 parameter type is null</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//efilm.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://eric.swiftzer.net/>EricLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>