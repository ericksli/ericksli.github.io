<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Jetpack DataStore 搭配 kotlinx.serialization Protobuf | EricLog</title>
<meta name=keywords content="Android,Kotlin"><meta name=description content="上月 kotlinx.serialization 出了 1.0 版。除了支援 JSON 之外，還有支援 Protocol Buffers (Protobuf)，而且還是跨平台支援。而在前一個月 Android 出了 Jetpack DataStore，它是一個用來取代 SharedPreferences 的 library。它有兩種用法："><meta name=author content><link rel=canonical href=https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/><link crossorigin=anonymous href=/assets/css/stylesheet.90d199bcefc47701be1700bdf90111f08c9ec8cafb7121eac1388d2f16c2cb69.css integrity="sha256-kNGZvO/EdwG+FwC9+QER8IyeyMr7cSHqwTiNLxbCy2k=" rel="preload stylesheet" as=style><link rel=icon href=https://eric.swiftzer.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://eric.swiftzer.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://eric.swiftzer.net/favicon-32x32.png><link rel=apple-touch-icon href=https://eric.swiftzer.net/apple-touch-icon.png><link rel=mask-icon href=https://eric.swiftzer.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@300&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-D93F946T73"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D93F946T73")}</script><meta property="og:url" content="https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/"><meta property="og:site_name" content="EricLog"><meta property="og:title" content="Jetpack DataStore 搭配 kotlinx.serialization Protobuf"><meta property="og:description" content="上月 kotlinx.serialization 出了 1.0 版。除了支援 JSON 之外，還有支援 Protocol Buffers (Protobuf)，而且還是跨平台支援。而在前一個月 Android 出了 Jetpack DataStore，它是一個用來取代 SharedPreferences 的 library。它有兩種用法："><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-14T18:52:34+08:00"><meta property="article:modified_time" content="2020-11-14T18:52:34+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Kotlin"><meta name=twitter:card content="summary"><meta name=twitter:title content="Jetpack DataStore 搭配 kotlinx.serialization Protobuf"><meta name=twitter:description content="上月 kotlinx.serialization 出了 1.0 版。除了支援 JSON 之外，還有支援 Protocol Buffers (Protobuf)，而且還是跨平台支援。而在前一個月 Android 出了 Jetpack DataStore，它是一個用來取代 SharedPreferences 的 library。它有兩種用法："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://eric.swiftzer.net/posts/"},{"@type":"ListItem","position":2,"name":"Jetpack DataStore 搭配 kotlinx.serialization Protobuf","item":"https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Jetpack DataStore 搭配 kotlinx.serialization Protobuf","name":"Jetpack DataStore 搭配 kotlinx.serialization Protobuf","description":"上月 kotlinx.serialization 出了 1.0 版。除了支援 JSON 之外，還有支援 Protocol Buffers (Protobuf)，而且還是跨平台支援。而在前一個月 Android 出了 Jetpack DataStore，它是一個用來取代 SharedPreferences 的 library。它有兩種用法：\n","keywords":["Android","Kotlin"],"articleBody":"上月 kotlinx.serialization 出了 1.0 版。除了支援 JSON 之外，還有支援 Protocol Buffers (Protobuf)，而且還是跨平台支援。而在前一個月 Android 出了 Jetpack DataStore，它是一個用來取代 SharedPreferences 的 library。它有兩種用法：\nPreferences DataStore：像 SharedPreferences 般以 key 存取資料，可以隨時加新 key，而且沒有特別的 type checking 處理，全靠讀取時指明 value 的 data type。 Proto DataStore：用 Protobuf 來儲存資料，存取時候都是直接經 Java/Kotlin class，所以和 SharedPreferences 及 Preferences DataStore 相比是 type safe。 既然要用 DataStore，那就當然要用 Proto DataStore。如果有看過 Codelab 的話，它都會叫大家用 com.google.protobuf:protoc 和 com.google.protobuf:protobuf-javalite 把 proto 檔案生成對應的 Java class。就像處理 JSON 要找 Gson 之類的 library 做 serialization/deserialization 一樣，不過 Protobuf 的用法是先定義好一個 proto 檔（即是 schema），然後把這個檔案交給 protoc compiler 生成不同程式語言的 entity class，然後會有另一個 library 做 entity class 和 protobuf serialization/deserialization。但其實 DataStore 的 API 設計並沒有硬性規定要用 Google 的 Protobuf library，甚至無規定用 Protobuf 格式。\nDataStore 的 API 就是提供一個 Kotlin Coroutine/Flow 的方式讀寫 object（Proto DataStore 的話）。這樣就可以逼大家把 I/O 動作放去其他 thread 執行（預設是用 Dispatchers.IO），又可以用 Flow observe 改動。相比起 SharedPreferences，SharedPreferences 的 API 大部分都是 synchronous，調用起來又很快，放在 UI thread 好像問題不大。但有時候改動 data 時用 apply() 後馬上讀取可能會讀不到最新值，用 commit() 又因為用 SharedPreferences 時未有考慮到寫入是 asynchronous 所以 linter 又出警告。所以 DataStore API 設計上就索性改用 Kotlin Coroutine/Flow。而用 Protobuf 儲資料是因為它既 type safe 又比 SharedPreferences 所用的 XML 細小。DataStore 的 Protobuf 存放位置跟 SharedPreferences 有點不同，它是放在 files/datastore 目錄內，而不是 shared_prefs 內。\nDataStore 存放位置 搭配 kotlinx.serialization ⚠️ 註：這篇文章是以 Jetpack DataStore 1.0.0-alpha03 來寫的。\n如果想改用 kotlinx.serialization 來處理 Protobuf 的話，首先要準備 data class。Data class 要有 @Serializable，property 最好要有 @ProtoNumber，以便日後 data class 增減 property 後 Protobuf 能夠相容。\nimport kotlinx.serialization.Serializable import kotlinx.serialization.protobuf.ProtoNumber @Serializable data class AssetConfig( @ProtoNumber(1) val version: String = \"\", @ProtoNumber(2) val path: String = \"\", ) 不要忘記加入 org.jetbrains.kotlin.plugin.serialization Gradle plugin 和 org.jetbrains.kotlinx:kotlinx-serialization-protobuf 到 module 的 dependency。沒有這兩個東西是不能夠做到 serialization/deserialization。\n之後要寫一個 DataStore Serializer。它是用來設定如果 file system 沒有那個 protobuf 時要回傳甚麼，還有是做 serialization 和 deserialization。由於我們的 data class 每個 property 都有預設值，所以 defaultValue 直接用 AssetConfig() 就算了。\n而 readFrom 是用來 deserialize Protobuf。我們要將 InputStream 的內容交去 kotlinx.serialization。InputStream 不需要 close，因為 androidx.datastore.core.SingleProcessDataStore 的 readData 在 call serializer 時已經有用 use 包住 FileInputStream，所以它會幫我們 close。use 就是 Java try-with-resources 的替代品。下面是 readData 的 code，除了那個 use 之外，還看到 defaultValue 的用法：\nprivate suspend fun readData(): T { try { FileInputStream(file).use { stream -\u003e return serializer.readFrom(stream) } } catch (ex: FileNotFoundException) { if (file.exists()) { throw ex } return serializer.defaultValue } } 之後要再 override writeTo，就是 readFrom 的相反。同樣是不要 close OutputStream。這次 KDoc 有寫明不可以 close。\nMarshal object to a stream. writeTo should not close output, doing so will result in an exception.\n下面就是完整的 Serializer：\nimport androidx.datastore.core.CorruptionException import androidx.datastore.core.Serializer import kotlinx.serialization.SerializationException import kotlinx.serialization.decodeFromByteArray import kotlinx.serialization.encodeToByteArray import kotlinx.serialization.protobuf.ProtoBuf import java.io.InputStream import java.io.OutputStream object AssetConfigSerializer : Serializer\u003cAssetConfig\u003e { override val defaultValue: AssetConfig get() = AssetConfig() override fun readFrom(input: InputStream): AssetConfig { return try { ProtoBuf.decodeFromByteArray(input.readBytes()) } catch (e: SerializationException) { throw CorruptionException(e.message.orEmpty(), e) } } override fun writeTo(t: AssetConfig, output: OutputStream) { output.write(ProtoBuf.encodeToByteArray(t)) } } 所以就是找到方法把 InputStream/OutputStream 和那個 object 互相轉換到就可以了，沒有限定要用那個 Protobuf library，甚至用其他格式都可以。\n使用 DataStore DataStore 使用上不太難用。首先是要取得 DataStore，這有點像 SharedPreferences，要提供 Protobuf 檔案名稱，另外要提供剛才做的 Serializer。\n如果要讀取就用 data，它是 Flow，有改動時就會通知。變更的話就用 updateData，lambda 會提供目前的 object。由於我們的 data class 全部 property 都是用 val，所以用了 copy。lambda 的 return value 就是將會寫入 Protobuf 的內容。\nimport androidx.datastore.createDataStore val dataStore: DataStore\u003cAssetConfig\u003e = context.createDataStore( fileName = \"asset_config.pb\", serializer = AssetConfigSerializer ) dataStore.data.collect { config -\u003e // new value of config } dataStore.updateData { config -\u003e // config is the current value config.copy(version = \"2.0\") } 用不用 DataStore 好 用 Jetpack DataStore 前期準備好像比 SharedPreferences 複雜（因為要準備 .proto 檔 / data class 又要寫一個 Serializer），但就多了 type safe 特性。如果你會把 JSON string 塞入 SharedPreferences 的話，用 DataStore 會比 SharedPreferences 好。因為 SharedPreferences 背後是儲存在 internal storage 的 XML 檔。如果 value 是 JSON 的話，那就是要 serialize/deserialize 兩次（用 SharedPreferences 的 getString deserialize 一次，之後再用 Gson 之類又再 deserialize 一次）。改用 DataStore 就直接由 Protobuf deserialize 一次就行。所以如果是 nested object 的話用 DataStore 其實是很好的。至於一般 key value 的話要看你想不想轉用。\n如果你有用 AndroidX Preference 的話，要留意需要重寫設定頁。因為 PreferenceFragmentCompat 本來就是配 SharedPreferences 來用，如果想自訂儲存方式的話，本來是可以用 PreferenceDataStore，但那些 method 都是 synchronous，所以現實上很難改到。不過大部分人都是自製設定頁，所以這部分問題不大。最大問題應該是要把全部本來用 SharedPreferences 的地方都要改做 asynchronous。如果當初寫的時候沒有把讀寫 SharedPreferences 的地方都有考慮到 asynchronous 的話那個改動就會超大，除非把 DataStore 的 Flow 和 Coroutine 都強行變成 runBlocking。\n至於 kotlinx.serialization 方面，你可能會留意到我們從來沒有寫過 .proto 檔。這是因為 kotlinx.serialization 是靠 Kotlin class 和 annotation 定義 schema，有別於其他 library 要由 .proto 生成 Java/Kotlin class 才能用。如果那個 Protobuf 只會在 Android app 用到，那問題不大。但如果要處理的 Protobuf 是跨平台（例如 backend 拍板 schema，其他地方例如 Android、iOS、Web 要跟那個 schema 的話），用 kotlinx.serialization 會比較尷尬。因為人家給你的 .proto 檔不能直接用，要自己對住它用 Kotlin 寫一次 data class。但寫的時候不能保證你寫的跟人家的 .proto 定義一致。如果不能 serialize/deserialize 又要額外花時間 debug。因為 kotlinx.serialization 定位是以 Kotlin 為中心，只需要 backend frontend 共用那個 Kotlin file 就能解決問題，完全不需要交換 .proto 檔。不過如果你有跨平台的考量需要交換 .proto 檔的話，那可能用 Google 的 Protobuf library 或者 Wire 之類比較合適。但如果情況是 backend 用 JSON，想在 Android 用 DataStore Proto 儲存的話（可能是一些零碎需要 offline cache 的內容），直接用 kotlinx.serialization 或許比較方便，因為可以共用同一個 Kotlin data class，kotlinx.serialization 的 annotation 又是跨格式共用的。\n","wordCount":"2395","inLanguage":"zh-tw","datePublished":"2020-11-14T18:52:34+08:00","dateModified":"2020-11-14T18:52:34+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/"},"publisher":{"@type":"Organization","name":"EricLog","logo":{"@type":"ImageObject","url":"https://eric.swiftzer.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://eric.swiftzer.net/ accesskey=h title="EricLog (Alt + H)">EricLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eric.swiftzer.net/fonts/ title=Fonts><span>Fonts</span></a></li><li><a href=https://eric.swiftzer.net/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://eric.swiftzer.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://eric.swiftzer.net/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://eric.swiftzer.net/>首頁</a>&nbsp;»&nbsp;<a href=https://eric.swiftzer.net/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Jetpack DataStore 搭配 kotlinx.serialization Protobuf</h1><div class=post-meta><span title='2020-11-14 18:52:34 +0800 +0800'>November 14, 2020</span></div></header><div class=post-content><p>上月 <a href=https://github.com/Kotlin/kotlinx.serialization>kotlinx.serialization</a> <a href=https://blog.jetbrains.com/kotlin/2020/10/kotlinx-serialization-1-0-released/>出了 1.0 版</a>。除了支援 JSON 之外，還有支援 <a href=https://developers.google.com/protocol-buffers>Protocol Buffers (Protobuf)</a>，而且還是跨平台支援。而在前一個月 Android 出了 <a href=https://developer.android.com/topic/libraries/architecture/datastore>Jetpack DataStore</a>，它是一個用來取代 <code>SharedPreferences</code> 的 library。它有兩種用法：</p><ol><li>Preferences DataStore：像 <code>SharedPreferences</code> 般以 key 存取資料，可以隨時加新 key，而且沒有特別的 type checking 處理，全靠讀取時指明 value 的 data type。</li><li>Proto DataStore：用 Protobuf 來儲存資料，存取時候都是直接經 Java/Kotlin class，所以和 <code>SharedPreferences</code> 及 Preferences DataStore 相比是 type safe。</li></ol><p>既然要用 DataStore，那就當然要用 Proto DataStore。如果有看過 <a href=https://developer.android.com/codelabs/android-proto-datastore>Codelab</a> 的話，它都會叫大家用 <code>com.google.protobuf:protoc</code> 和 <code>com.google.protobuf:protobuf-javalite</code> 把 proto 檔案生成對應的 Java class。就像處理 JSON 要找 Gson 之類的 library 做 serialization/deserialization 一樣，不過 Protobuf 的用法是先定義好一個 proto 檔（即是 schema），然後把這個檔案交給 protoc compiler 生成不同程式語言的 entity class，然後會有另一個 library 做 entity class 和 protobuf serialization/deserialization。但其實 DataStore 的 API 設計並沒有硬性規定要用 Google 的 Protobuf library，甚至無規定用 Protobuf 格式。</p><p>DataStore 的 API 就是提供一個 Kotlin Coroutine/Flow 的方式讀寫 object（Proto DataStore 的話）。這樣就可以逼大家把 I/O 動作放去其他 thread 執行（預設是用 <code>Dispatchers.IO</code>），又可以用 Flow observe 改動。相比起 <code>SharedPreferences</code>，<code>SharedPreferences</code> 的 API 大部分都是 synchronous，調用起來又很快，放在 UI thread 好像問題不大。但有時候改動 data 時用 <code>apply()</code> 後馬上讀取可能會讀不到最新值，用 <code>commit()</code> 又因為用 <code>SharedPreferences</code> 時未有考慮到寫入是 asynchronous 所以 linter 又出警告。所以 DataStore API 設計上就索性改用 Kotlin Coroutine/Flow。而用 Protobuf 儲資料是因為它既 type safe 又比 <code>SharedPreferences</code> 所用的 XML 細小。DataStore 的 Protobuf 存放位置跟 <code>SharedPreferences</code> 有點不同，它是放在 <em>files/datastore</em> 目錄內，而不是 <em>shared_prefs</em> 內。</p><figure><img loading=lazy src=datastore-file-location.png><figcaption>DataStore 存放位置</figcaption></figure><h2 id=搭配-kotlinxserialization>搭配 kotlinx.serialization<a hidden class=anchor aria-hidden=true href=#搭配-kotlinxserialization>#</a></h2><p>⚠️ 註：這篇文章是以 Jetpack DataStore 1.0.0-alpha03 來寫的。</p><p>如果想改用 kotlinx.serialization 來處理 Protobuf 的話，首先要準備 data class。Data class 要有 <code>@Serializable</code>，property 最好要有 <code>@ProtoNumber</code>，以便日後 data class 增減 property 後 Protobuf 能夠相容。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlinx.serialization.Serializable</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlinx.serialization.protobuf.ProtoNumber</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Serializable</span>
</span></span><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>AssetConfig</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nd>@ProtoNumber</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>val</span> <span class=py>version</span><span class=p>:</span> <span class=n>String</span> <span class=p>=</span> <span class=s2>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nd>@ProtoNumber</span><span class=p>(</span><span class=m>2</span><span class=p>)</span> <span class=k>val</span> <span class=py>path</span><span class=p>:</span> <span class=n>String</span> <span class=p>=</span> <span class=s2>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span></span></span></code></pre></div><p>不要忘記加入 <code>org.jetbrains.kotlin.plugin.serialization</code> Gradle plugin 和 <code>org.jetbrains.kotlinx:kotlinx-serialization-protobuf</code> 到 module 的 dependency。沒有這兩個東西是不能夠做到 serialization/deserialization。</p><p>之後要寫一個 DataStore <code>Serializer</code>。它是用來設定如果 file system 沒有那個 protobuf 時要回傳甚麼，還有是做 serialization 和 deserialization。由於我們的 data class 每個 property 都有預設值，所以 <code>defaultValue</code> 直接用 <code>AssetConfig()</code> 就算了。</p><p>而 <code>readFrom</code> 是用來 deserialize Protobuf。我們要將 <code>InputStream</code> 的內容交去 kotlinx.serialization。<code>InputStream</code> 不需要 close，因為 <code>androidx.datastore.core.SingleProcessDataStore</code> 的 <code>readData</code> 在 call <code>serializer</code> 時已經有用 <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html><code>use</code></a> 包住 <code>FileInputStream</code>，所以它會幫我們 close。<code>use</code> 就是 Java <a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html>try-with-resources</a> 的替代品。下面是 <code>readData</code> 的 code，除了那個 <code>use</code> 之外，還看到 <code>defaultValue</code> 的用法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>private</span> <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>readData</span><span class=p>():</span> <span class=n>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>FileInputStream</span><span class=p>(</span><span class=k>file</span><span class=p>).</span><span class=n>use</span> <span class=p>{</span> <span class=n>stream</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>serializer</span><span class=p>.</span><span class=n>readFrom</span><span class=p>(</span><span class=n>stream</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>ex</span><span class=p>:</span> <span class=n>FileNotFoundException</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=k>file</span><span class=p>.</span><span class=n>exists</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>ex</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>serializer</span><span class=p>.</span><span class=n>defaultValue</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>之後要再 override <code>writeTo</code>，就是 <code>readFrom</code> 的相反。同樣是不要 close <code>OutputStream</code>。這次 KDoc 有寫明不可以 close。</p><blockquote><p>Marshal object to a stream. writeTo should not close output, doing so will result in an exception.</p></blockquote><p>下面就是完整的 <code>Serializer</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>import</span> <span class=nn>androidx.datastore.core.CorruptionException</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>androidx.datastore.core.Serializer</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlinx.serialization.SerializationException</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlinx.serialization.decodeFromByteArray</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlinx.serialization.encodeToByteArray</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>kotlinx.serialization.protobuf.ProtoBuf</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>java.io.InputStream</span>
</span></span><span class=line><span class=cl><span class=k>import</span> <span class=nn>java.io.OutputStream</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>object</span> <span class=nc>AssetConfigSerializer</span> <span class=p>:</span> <span class=n>Serializer</span><span class=p>&lt;</span><span class=n>AssetConfig</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>val</span> <span class=py>defaultValue</span><span class=p>:</span> <span class=n>AssetConfig</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=n>AssetConfig</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>readFrom</span><span class=p>(</span><span class=n>input</span><span class=p>:</span> <span class=n>InputStream</span><span class=p>):</span> <span class=n>AssetConfig</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nc>ProtoBuf</span><span class=p>.</span><span class=n>decodeFromByteArray</span><span class=p>(</span><span class=n>input</span><span class=p>.</span><span class=n>readBytes</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>e</span><span class=p>:</span> <span class=n>SerializationException</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>CorruptionException</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>message</span><span class=p>.</span><span class=n>orEmpty</span><span class=p>(),</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>writeTo</span><span class=p>(</span><span class=n>t</span><span class=p>:</span> <span class=n>AssetConfig</span><span class=p>,</span> <span class=n>output</span><span class=p>:</span> <span class=n>OutputStream</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>output</span><span class=p>.</span><span class=n>write</span><span class=p>(</span><span class=nc>ProtoBuf</span><span class=p>.</span><span class=n>encodeToByteArray</span><span class=p>(</span><span class=n>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>所以就是找到方法把 <code>InputStream</code>/<code>OutputStream</code> 和那個 object 互相轉換到就可以了，沒有限定要用那個 Protobuf library，甚至用其他格式都可以。</p><h2 id=使用-datastore>使用 DataStore<a hidden class=anchor aria-hidden=true href=#使用-datastore>#</a></h2><p>DataStore 使用上不太難用。首先是要取得 <code>DataStore</code>，這有點像 <code>SharedPreferences</code>，要提供 Protobuf 檔案名稱，另外要提供剛才做的 <code>Serializer</code>。</p><p>如果要讀取就用 <code>data</code>，它是 <code>Flow</code>，有改動時就會通知。變更的話就用 <code>updateData</code>，lambda 會提供目前的 object。由於我們的 data class 全部 property 都是用 <code>val</code>，所以用了 <code>copy</code>。lambda 的 return value 就是將會寫入 Protobuf 的內容。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>import</span> <span class=nn>androidx.datastore.createDataStore</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>dataStore</span><span class=p>:</span> <span class=n>DataStore</span><span class=p>&lt;</span><span class=n>AssetConfig</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>context</span><span class=p>.</span><span class=n>createDataStore</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>fileName</span> <span class=p>=</span> <span class=s2>&#34;asset_config.pb&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>serializer</span> <span class=p>=</span> <span class=n>AssetConfigSerializer</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>dataStore</span><span class=p>.</span><span class=k>data</span><span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>config</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// new value of config
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>dataStore</span><span class=p>.</span><span class=n>updateData</span> <span class=p>{</span> <span class=n>config</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// config is the current value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>config</span><span class=p>.</span><span class=n>copy</span><span class=p>(</span><span class=n>version</span> <span class=p>=</span> <span class=s2>&#34;2.0&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=用不用-datastore-好>用不用 DataStore 好<a hidden class=anchor aria-hidden=true href=#用不用-datastore-好>#</a></h2><p>用 Jetpack DataStore 前期準備好像比 <code>SharedPreferences</code> 複雜（因為要準備 .proto 檔 / data class 又要寫一個 <code>Serializer</code>），但就多了 type safe 特性。如果你會把 JSON string 塞入 <code>SharedPreferences</code> 的話，用 DataStore 會比 <code>SharedPreferences</code> 好。因為 <code>SharedPreferences</code> 背後是儲存在 internal storage 的 XML 檔。如果 value 是 JSON 的話，那就是要 serialize/deserialize 兩次（用 <code>SharedPreferences</code> 的 <code>getString</code> deserialize 一次，之後再用 Gson 之類又再 deserialize 一次）。改用 DataStore 就直接由 Protobuf deserialize 一次就行。所以如果是 nested object 的話用 DataStore 其實是很好的。至於一般 key value 的話要看你想不想轉用。</p><p>如果你有用 <a href=https://developer.android.com/guide/topics/ui/settings>AndroidX Preference</a> 的話，要留意需要重寫設定頁。因為 <code>PreferenceFragmentCompat</code> 本來就是配 <code>SharedPreferences</code> 來用，如果想自訂儲存方式的話，本來是可以用 <a href=https://developer.android.com/guide/topics/ui/settings/use-saved-values#custom-data-store><code>PreferenceDataStore</code></a>，但那些 method 都是 synchronous，所以現實上很難改到。不過大部分人都是自製設定頁，所以這部分問題不大。最大問題應該是要把全部本來用 <code>SharedPreferences</code> 的地方都要改做 asynchronous。如果當初寫的時候沒有把讀寫 <code>SharedPreferences</code> 的地方都有考慮到 asynchronous 的話那個改動就會超大，除非把 DataStore 的 Flow 和 Coroutine 都強行變成 <code>runBlocking</code>。</p><p>至於 kotlinx.serialization 方面，你可能會留意到我們從來沒有寫過 .proto 檔。這是因為 kotlinx.serialization 是靠 Kotlin class 和 annotation 定義 schema，有別於其他 library 要由 .proto 生成 Java/Kotlin class 才能用。如果那個 Protobuf 只會在 Android app 用到，那問題不大。但如果要處理的 Protobuf 是跨平台（例如 backend 拍板 schema，其他地方例如 Android、iOS、Web 要跟那個 schema 的話），用 kotlinx.serialization 會比較尷尬。因為人家給你的 .proto 檔不能直接用，要自己對住它用 Kotlin 寫一次 data class。但寫的時候不能保證你寫的跟人家的 .proto 定義一致。如果不能 serialize/deserialize 又要額外花時間 debug。因為 kotlinx.serialization 定位是以 Kotlin 為中心，只需要 backend frontend 共用那個 Kotlin file 就能解決問題，完全不需要交換 .proto 檔。不過如果你有跨平台的考量需要交換 .proto 檔的話，那可能用 Google 的 Protobuf library 或者 <a href=https://square.github.io/wire/>Wire</a> 之類比較合適。但如果情況是 backend 用 JSON，想在 Android 用 DataStore Proto 儲存的話（可能是一些零碎需要 offline cache 的內容），直接用 kotlinx.serialization 或許比較方便，因為可以共用同一個 Kotlin data class，kotlinx.serialization 的 annotation 又是跨格式共用的。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://eric.swiftzer.net/tags/android/>Android</a></li><li><a href=https://eric.swiftzer.net/tags/kotlin/>Kotlin</a></li></ul><nav class=paginav><a class=prev href=https://eric.swiftzer.net/2021/03/notification-channel-custom-sound/><span class=title>« 上一頁</span><br><span>Notification Channel 自訂音效</span>
</a><a class=next href=https://eric.swiftzer.net/2020/08/conventional-commits-commitlint/><span class=title>下一頁 »</span><br><span>Conventional Commits 和 commitlint</span></a></nav></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//efilm.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://eric.swiftzer.net/>EricLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>