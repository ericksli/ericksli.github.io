<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Firebase Cloud Messaging | EricLog</title>
<meta name=keywords content="Android,Firebase"><meta name=description content="最近工作需要做 Firebase Cloud Messaging (FCM) 整合，發現了向 Firebase API 直接送出 push 的 HTTP request 都可以生成不同種類的 message。
如果要整合到 Android 的話，需要建立一個新的 Service class 並繼承自 FirebaseMessagingService。這個 Service 有一個叫 onMessageReceived 的 callback method 來接收來自 FCM 的 push 和它的 payload。但原來不是所有的 push 都能被那個 callback 接到，要視乎 push 的種類和你的 app 當時在甚麼情況而定。"><meta name=author content><link rel=canonical href=https://eric.swiftzer.net/2020/02/firebase-cloud-messaging/><link crossorigin=anonymous href=/assets/css/stylesheet.6af4cf50660ceaa7cb5315be4c4bf349a5f8e72eee8939bab4dd32dcf0378f25.css integrity="sha256-avTPUGYM6qfLUxW+TEvzSaX45y7uiTm6tN0y3PA3jyU=" rel="preload stylesheet" as=style><link rel=icon href=https://eric.swiftzer.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://eric.swiftzer.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://eric.swiftzer.net/favicon-32x32.png><link rel=apple-touch-icon href=https://eric.swiftzer.net/apple-touch-icon.png><link rel=mask-icon href=https://eric.swiftzer.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://eric.swiftzer.net/2020/02/firebase-cloud-messaging/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@300&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-D93F946T73"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D93F946T73")}</script><meta property="og:url" content="https://eric.swiftzer.net/2020/02/firebase-cloud-messaging/"><meta property="og:site_name" content="EricLog"><meta property="og:title" content="Firebase Cloud Messaging"><meta property="og:description" content="最近工作需要做 Firebase Cloud Messaging (FCM) 整合，發現了向 Firebase API 直接送出 push 的 HTTP request 都可以生成不同種類的 message。
如果要整合到 Android 的話，需要建立一個新的 Service class 並繼承自 FirebaseMessagingService。這個 Service 有一個叫 onMessageReceived 的 callback method 來接收來自 FCM 的 push 和它的 payload。但原來不是所有的 push 都能被那個 callback 接到，要視乎 push 的種類和你的 app 當時在甚麼情況而定。"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-29T14:07:18+08:00"><meta property="article:modified_time" content="2020-02-29T14:07:18+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Firebase"><meta name=twitter:card content="summary"><meta name=twitter:title content="Firebase Cloud Messaging"><meta name=twitter:description content="最近工作需要做 Firebase Cloud Messaging (FCM) 整合，發現了向 Firebase API 直接送出 push 的 HTTP request 都可以生成不同種類的 message。
如果要整合到 Android 的話，需要建立一個新的 Service class 並繼承自 FirebaseMessagingService。這個 Service 有一個叫 onMessageReceived 的 callback method 來接收來自 FCM 的 push 和它的 payload。但原來不是所有的 push 都能被那個 callback 接到，要視乎 push 的種類和你的 app 當時在甚麼情況而定。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://eric.swiftzer.net/posts/"},{"@type":"ListItem","position":2,"name":"Firebase Cloud Messaging","item":"https://eric.swiftzer.net/2020/02/firebase-cloud-messaging/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Firebase Cloud Messaging","name":"Firebase Cloud Messaging","description":"最近工作需要做 Firebase Cloud Messaging (FCM) 整合，發現了向 Firebase API 直接送出 push 的 HTTP request 都可以生成不同種類的 message。\n如果要整合到 Android 的話，需要建立一個新的 Service class 並繼承自 FirebaseMessagingService。這個 Service 有一個叫 onMessageReceived 的 callback method 來接收來自 FCM 的 push 和它的 payload。但原來不是所有的 push 都能被那個 callback 接到，要視乎 push 的種類和你的 app 當時在甚麼情況而定。\n","keywords":["Android","Firebase"],"articleBody":"最近工作需要做 Firebase Cloud Messaging (FCM) 整合，發現了向 Firebase API 直接送出 push 的 HTTP request 都可以生成不同種類的 message。\n如果要整合到 Android 的話，需要建立一個新的 Service class 並繼承自 FirebaseMessagingService。這個 Service 有一個叫 onMessageReceived 的 callback method 來接收來自 FCM 的 push 和它的 payload。但原來不是所有的 push 都能被那個 callback 接到，要視乎 push 的種類和你的 app 當時在甚麼情況而定。\nFCM 的 push 有分兩種：Notification message 和 Data message。Notification message 就是那些在發送時預先指明式樣的 push。即是標題、內文、notification channel 之類的 push。這種 push 可以用 Firebase 的 Notifications composer 造出來，完全不用寫 code。如果裝置收到 push 時你的 app 是在 foreground 的話就會觸發 onMessageReceived callback 讓你自己處理；在 background 時就直接後會由 Firebase SDK 直接生成 Android 看到的系統通知（即是在 system tray 看到的 NotificationCompat）而不會觸發 onMessageReceived callback。如果要在 Firebase API 發送 push 的話 request body 大概是這樣：\n{ \"message\": { \"token\": \"bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...\", \"notification\": { \"title\": \"Portugal vs. Denmark\", \"body\": \"great match!\" } } } 而 Data message 就不會由 Firebase SDK 自動生成 UI，不管你的 app 是在 foreground 還是 background 都是要靠自已在 FirebaseMessagingService 的 onMessageReceived callback 生成 NotificationCompat 才會顯示出來（Notification message 不論 app 是在 foreground 還是 background 都會觸發 onMessageReceived callback）。而它只會附帶 key-value pair payload，沒有那些預先設計好的標題、內文欄之類。Firebase API 的 request body 會是這樣：\n{ \"message\": { \"token\": \"bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...\", \"data\": { \"Nick\": \"Mario\", \"body\": \"great match!\", \"Room\": \"PortugalVSDenmark\" } } } 但其實一個 push 可以兩者皆是，即是又可以提供用戶可見的標題、內文，又可以提供自訂的 key-value pair payload。Firebase API 的 request body 又會是這樣：\n{ \"message\": { \"token\":\"bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...\", \"notification\": { \"title\": \"Portugal vs. Denmark\", \"body\": \"great match!\" }, \"data\": { \"Nick\": \"Mario\", \"Room\": \"PortugalVSDenmark\" } } } 跟之前兩款不同的地方是它既有 notification 又有 data 兩個 object。在這種情況下 app 是在 foreground 的話會觸發 onMessageReceived callback；在 background 的話就像 Notification message 般直接在裝置的 system tray 顯示 notification。當用戶按下 notification 開 app 時那些 payload 就會由 intent extra 送到預設開 app 的 Activity 內。\n所以如果你想不論何時都能讓 app 即時處理到 push 的話，那就不要附帶 notification object。這樣就變成 Notification message，不論 foreground 還是 background 都可以被 app 收到。\n用了 Notification message 但 onMessageReceived 沒有被 call 有時即使裝置已經收到 Notification message 的 push 但仍然收不到 onMessageReceived callback，在 Logcat 可以看到這段 log：\n2020-02-18 11:36:41.862 3369-3369/? W/GCM: broadcast intent callback: result=CANCELLED forIntent { act=com.google.android.c2dm.intent.RECEIVE pkg=net.swiftzer.metroride (has extras) } 這個情況在 Firebase 的文檔應該沒有提及，但 Stack Overflow 有人回答過相同問題。沒有 callback 但出現以上的 log 原因是因為這就是 Android framework 的設計：如果用戶主動 kill app 的話即使收到 FCM push 都不會啟動你的 app，直至用戶再次主動開啟你的 app 才會解除限制，重新開機也不可重設，一定要主動開 app 才會解除。用戶主動 kill app 是指用戶在設定頁找到你的 app 再按強制停止，如果是因為系統不夠 RAM 而 kill app 就不算。\n但這個回答有提過這個機制在某些品牌會變成用戶在最近使用 app 的畫面掃走 app 時都會有這個效果。所以比較穏妥的做法是如果那個 notification 不需要 app 去特別處理（例如 payload 的話）都附帶 notification object。\n參考 About FCM messages（上面的 JSON 都是在那裏抄的） Receive messages in an Android app Error broadcast intent callback: result=CANCELLED forIntent { act=com.google.android.c2dm.intent.RECEIVE pkg=com.flagg327.guicomaipu (has extras) } ","wordCount":"1192","inLanguage":"zh-tw","datePublished":"2020-02-29T14:07:18+08:00","dateModified":"2020-02-29T14:07:18+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://eric.swiftzer.net/2020/02/firebase-cloud-messaging/"},"publisher":{"@type":"Organization","name":"EricLog","logo":{"@type":"ImageObject","url":"https://eric.swiftzer.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://eric.swiftzer.net/ accesskey=h title="EricLog (Alt + H)">EricLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eric.swiftzer.net/fonts/ title=Fonts><span>Fonts</span></a></li><li><a href=https://eric.swiftzer.net/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://eric.swiftzer.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://eric.swiftzer.net/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://eric.swiftzer.net/>首頁</a>&nbsp;»&nbsp;<a href=https://eric.swiftzer.net/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Firebase Cloud Messaging</h1><div class=post-meta><span title='2020-02-29 14:07:18 +0800 +0800'>February 29, 2020</span></div></header><div class=post-content><p>最近工作需要做 Firebase Cloud Messaging (FCM) 整合，發現了向 Firebase API 直接送出 push 的 HTTP request 都可以生成不同種類的 message。</p><p>如果要整合到 Android 的話，需要建立一個新的 <code>Service</code> class 並繼承自 <a href=https://firebase.google.com/docs/reference/android/com/google/firebase/messaging/FirebaseMessagingService><code>FirebaseMessagingService</code></a>。這個 <code>Service</code> 有一個叫 <code>onMessageReceived</code> 的 callback method 來接收來自 FCM 的 push 和它的 payload。但原來不是所有的 push 都能被那個 callback 接到，要視乎 push 的種類和你的 app 當時在甚麼情況而定。</p><p>FCM 的 push 有分兩種：Notification message 和 Data message。Notification message 就是那些在發送時預先指明式樣的 push。即是標題、內文、<a href=https://developer.android.com/training/notify-user/channels>notification channel</a> 之類的 push。這種 push 可以用 Firebase 的 <a href=https://console.firebase.google.com/u/0/project/_/notification>Notifications composer</a> 造出來，完全不用寫 code。如果裝置收到 push 時你的 app 是在 foreground 的話就會觸發 <code>onMessageReceived</code> callback 讓你自己處理；在 background 時就直接後會由 Firebase SDK 直接生成 Android 看到的系統通知（即是在 system tray 看到的 <code>NotificationCompat</code>）而不會觸發 <code>onMessageReceived</code> callback。如果要在 Firebase API 發送 push 的話 request body 大概是這樣：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;token&#34;</span><span class=p>:</span> <span class=s2>&#34;bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;notification&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;title&#34;</span><span class=p>:</span> <span class=s2>&#34;Portugal vs. Denmark&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;body&#34;</span><span class=p>:</span> <span class=s2>&#34;great match!&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>而 Data message 就不會由 Firebase SDK 自動生成 UI，不管你的 app 是在 foreground 還是 background 都是要靠自已在 <code>FirebaseMessagingService</code> 的 <code>onMessageReceived</code> callback 生成 <code>NotificationCompat</code> 才會顯示出來（Notification message 不論 app 是在 foreground 還是 background 都會觸發 <code>onMessageReceived</code> callback）。而它只會附帶 key-value pair payload，沒有那些預先設計好的標題、內文欄之類。Firebase API 的 request body 會是這樣：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;token&#34;</span><span class=p>:</span> <span class=s2>&#34;bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;data&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;Nick&#34;</span><span class=p>:</span> <span class=s2>&#34;Mario&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;body&#34;</span><span class=p>:</span> <span class=s2>&#34;great match!&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;Room&#34;</span><span class=p>:</span> <span class=s2>&#34;PortugalVSDenmark&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>但其實一個 push 可以兩者皆是，即是又可以提供用戶可見的標題、內文，又可以提供自訂的 key-value pair payload。Firebase API 的 request body 又會是這樣：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;token&#34;</span><span class=p>:</span><span class=s2>&#34;bk3RNwTe3H0:CI2k_HHwgIpoDKCIZvvDMExUdFQ3P1...&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;notification&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;title&#34;</span><span class=p>:</span> <span class=s2>&#34;Portugal vs. Denmark&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;body&#34;</span><span class=p>:</span> <span class=s2>&#34;great match!&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;data&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;Nick&#34;</span><span class=p>:</span> <span class=s2>&#34;Mario&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;Room&#34;</span><span class=p>:</span> <span class=s2>&#34;PortugalVSDenmark&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>跟之前兩款不同的地方是它既有 <code>notification</code> 又有 <code>data</code> 兩個 object。在這種情況下 app 是在 foreground 的話會觸發 <code>onMessageReceived</code> callback；在 background 的話就像 Notification message 般直接在裝置的 system tray 顯示 notification。當用戶按下 notification 開 app 時那些 payload 就會由 intent extra 送到預設開 app 的 <code>Activity</code> 內。</p><p>所以如果你想不論何時都能讓 app 即時處理到 push 的話，那就不要附帶 <code>notification</code> object。這樣就變成 Notification message，不論 foreground 還是 background 都可以被 app 收到。</p><h2 id=用了-notification-message-但-onmessagereceived-沒有被-call>用了 Notification message 但 <code>onMessageReceived</code> 沒有被 call<a hidden class=anchor aria-hidden=true href=#用了-notification-message-但-onmessagereceived-沒有被-call>#</a></h2><p>有時即使裝置已經收到 Notification message 的 push 但仍然收不到 <code>onMessageReceived</code> callback，在 Logcat 可以看到這段 log：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>2020-02-18 11:36:41.862 3369-3369/? W/GCM: broadcast intent callback: result=CANCELLED forIntent { act=com.google.android.c2dm.intent.RECEIVE pkg=net.swiftzer.metroride (has extras) }
</span></span></code></pre></div><p>這個情況在 Firebase 的文檔應該沒有提及，但 <a href=https://stackoverflow.com/a/53404817>Stack Overflow</a> 有人回答過相同問題。沒有 callback 但出現以上的 log 原因是因為這就是 Android framework 的設計：如果用戶主動 kill app 的話即使收到 FCM push 都不會啟動你的 app，直至用戶再次主動開啟你的 app 才會解除限制，重新開機也不可重設，一定要主動開 app 才會解除。用戶主動 kill app 是指用戶在設定頁找到你的 app 再按強制停止，如果是因為系統不夠 RAM 而 kill app 就不算。</p><p>但這個回答有提過這個機制在某些品牌會變成用戶在最近使用 app 的畫面掃走 app 時都會有這個效果。所以比較穏妥的做法是如果那個 notification 不需要 app 去特別處理（例如 payload 的話）都附帶 <code>notification</code> object。</p><h2 id=參考>參考<a hidden class=anchor aria-hidden=true href=#參考>#</a></h2><ul><li><a href=https://firebase.google.com/docs/cloud-messaging/concept-options>About FCM messages</a>（上面的 JSON 都是在那裏抄的）</li><li><a href=https://firebase.google.com/docs/cloud-messaging/android/receive>Receive messages in an Android app</a></li><li><a href=https://stackoverflow.com/questions/39480931/error-broadcast-intent-callback-result-cancelled-forintent-act-com-google-and>Error broadcast intent callback: result=CANCELLED forIntent { act=com.google.android.c2dm.intent.RECEIVE pkg=com.flagg327.guicomaipu (has extras) }</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://eric.swiftzer.net/tags/android/>Android</a></li><li><a href=https://eric.swiftzer.net/tags/firebase/>Firebase</a></li></ul><nav class=paginav><a class=prev href=https://eric.swiftzer.net/2020/03/firebase-crashlyticsorgidexception/><span class=title>« 上一頁</span><br><span>Firebase Crashlytics 的 CrashlyticsOrgIdException 解決方法</span>
</a><a class=next href=https://eric.swiftzer.net/2019/07/android-app-icon-specification/><span class=title>下一頁 »</span><br><span>Android App Icon 規格</span></a></nav></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//efilm.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://eric.swiftzer.net/>EricLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>