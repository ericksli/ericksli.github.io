<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2021 iThome 鐵人賽 Day 6：HTTP Client | EricLog</title><meta name=keywords content="2021 iThome 鐵人賽,Android"><meta name=description content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 6 篇，你可到 iThome 查看原文。 文章目錄 在 Android 開發如果要用到 HTTP client 的話基本上大家都預設用 OkHttp"><meta name=author content><link rel=canonical href=https://ithelp.ithome.com.tw/articles/10268767><link crossorigin=anonymous href=/assets/css/stylesheet.48ed1b8bd3873bc86534e1a6b0ba618b6c80d8a975cf0cf1f1835c2b89c5c5b0.css integrity="sha256-SO0bi9OHO8hlNOGmsLphi2yA2Kl1zwzx8YNcK4nFxbA=" rel="preload stylesheet" as=style><link rel=icon href=https://eric.swiftzer.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://eric.swiftzer.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://eric.swiftzer.net/favicon-32x32.png><link rel=apple-touch-icon href=https://eric.swiftzer.net/apple-touch-icon.png><link rel=mask-icon href=https://eric.swiftzer.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@300&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-D93F946T73"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D93F946T73",{anonymize_ip:!1})}</script><meta property="og:title" content="2021 iThome 鐵人賽 Day 6：HTTP Client"><meta property="og:description" content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 6 篇，你可到 iThome 查看原文。 文章目錄 在 Android 開發如果要用到 HTTP client 的話基本上大家都預設用 OkHttp"><meta property="og:type" content="article"><meta property="og:url" content="https://eric.swiftzer.net/2021/09/2021-ithome-ironman-06-http-client/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-21T00:00:00+08:00"><meta property="article:modified_time" content="2021-09-21T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="2021 iThome 鐵人賽 Day 6：HTTP Client"><meta name=twitter:description content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 6 篇，你可到 iThome 查看原文。 文章目錄 在 Android 開發如果要用到 HTTP client 的話基本上大家都預設用 OkHttp"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://eric.swiftzer.net/posts/"},{"@type":"ListItem","position":2,"name":"2021 iThome 鐵人賽 Day 6：HTTP Client","item":"https://eric.swiftzer.net/2021/09/2021-ithome-ironman-06-http-client/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2021 iThome 鐵人賽 Day 6：HTTP Client","name":"2021 iThome 鐵人賽 Day 6：HTTP Client","description":"本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 6 篇，你可到 iThome 查看原文。 文章目錄 在 Android 開發如果要用到 HTTP client 的話基本上大家都預設用 OkHttp","keywords":["2021 iThome 鐵人賽","Android"],"articleBody":" 本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 6 篇，你可到 iThome 查看原文。\n文章目錄\n在 Android 開發如果要用到 HTTP client 的話基本上大家都預設用 OkHttp + Retrofit 這個組合。這次我們試試一些新東西：Ktor。\nKtor 是 JetBrains 出的 server library，就是用來開發 server side 的 web application。但它的功能比較簡單。不過我們不是用它的 server library，是用它的 client library。近年來 Kotlin 推廣用 Kotlin 寫跨平台應用（網頁、Android、iOS、backend），在 mobile app 那邊叫 Kotlin Multiplatform Mobile (KMM)，它就是要用 Kotlin 來寫 Android 和 iOS 共用的部分（通常就是 business logic、接駁 backend 那部分），至於 UI 的部分就各自用回該平台的方法寫。正因為共通的部分必須要用純 Kotlin 來寫，code 不能引用 Java Standard Library 的東西，所以 OkHttp 和 Retrofit 就不能直接在 KMM 上面用，取而代之就是 Ktor Client。\n因應不同平台實際處理 HTTP request 的 client（Ktor 稱為 engine）各有不同，Ktor 把這些 HTTP client 封裝了一次。例如在 Android 可以用 OkHttp、CIO，在 iOS 就是用 NSURLSession。所以在建立 Ktor client 時要因應不同平台有不同的設定，但你調用 Ktor 的地方就不用加那些 if (Android) { ... } 的東西。\n以下是我們這次會用到的 dependency：\nimplementation \"io.ktor:ktor-client-core:$ktorVersion\" implementation \"io.ktor:ktor-client-okhttp:$ktorVersion\" implementation \"io.ktor:ktor-client-logging:$ktorVersion\" implementation \"io.ktor:ktor-client-serialization:$ktorVersion\" testImplementation \"io.ktor:ktor-client-mock:$ktorVersion\" implementation \"com.squareup.okhttp3:okhttp:$okhttpVersion\" implementation \"org.jetbrains.kotlinx:kotlinx-serialization-json:$kotlinSerializationVersion\" // logging the HTTP request and response implementation \"org.slf4j:slf4j-api:$slf4jVersion\" implementation \"com.github.tony19:logback-android:$logbackAndroidVersion\" Ktor Client 基本用法 如果我們甚麼都不理，只是單純用 Ktor client call API 的話，大概會是這樣：\nval httpClient = HttpClient(OkHttp) { expectSuccess = true install(Logging) { logger = Logger.DEFAULT level = LogLevel.ALL } install(JsonFeature) { serializer = KotlinxSerializer(kotlinx.serialization.json.Json { coerceInputValues = true ignoreUnknownKeys = true }) } } val response: EtaResponse = httpClient.get\u003cEtaResponse\u003e(\"https://rt.data.gov.hk/v1/transport/mtr/getSchedule.php?line=TML\u0026sta=TIS\u0026lang=TC\") 設定 Ktor client 的寫法用了很多 lambda，就像那些 build.gradle 般做了專門而設的 DSL。上面的 HTTP client 設定就是幫它加了 logging 和用 Kotlin Serialization 做 JSON deserialization。\n然後發送 HTTP request 就是簡單一句 httpClient.get 就能拿到 deserialize 好的 response data class object。\n如果見到網址有一大串 query parameter 感覺不爽的話，可以寫成這樣：\nhttpClient.get\u003cEtaResponse\u003e(\"https://rt.data.gov.hk/v1/transport/mtr/getSchedule.php\") { parameter(\"line\", \"TML\") parameter(\"sta\", \"TIS\") parameter(\"lang\", \"TC\") } 這個 httpClient.get 是 suspending function，IDE 會在 suspending function 的行數顯示箭頭型的 gutter icon 作提示。Suspending function 要有 Coroutine scope 包住才能用，以 Activity 為例，你不能在 onCreate 內 call 這一句，因為 onCreate 不是 suspending function，只有在 suspending function 內才能 call 另一個 suspending function，或者是在 coroutine scope 內。簡單來講，coroutine scope 就是用來連接 coroutine 和非 coroutine 的地方，coroutine scope 另一個用途是用來一併停止未完結的 suspending function，例如 onDestroy 時就可以 call coroutine scope 的 cancel。這個意念跟 RxJava 的 CompositeDisposable 類似。其實現在 AndroidX 的 library 已經幫我們在 Activity、Fragment、ViewModel 等地方為我們造好了對應其 lifecycle 的 coroutine scope，我們只需要直接調用就可以了，詳細的內容我們之後會示範。\nDagger 設定 看過基本用法後我們要把 Ktor client 的設置放到 Dagger module 入面，這樣就可以經 Dagger 取得 Ktor client 的 instance。以下是大約的寫法：\n@Module @InstallIn(SingletonComponent::class) interface DataModule { @BindsOptionalOf fun bindLogging(): HttpClientFeature\u003cLogging.Config, Logging\u003e companion object { @Provides @Singleton fun provideOkHttpClient(): OkHttpClient = OkHttpClient.Builder() .build() @Provides fun provideHttpClientEngine(okHttpClient: OkHttpClient): HttpClientEngine = OkHttp.create { preconfigured = okHttpClient } @Provides fun provideLogging(): HttpClientFeature\u003cLogging.Config, Logging\u003e = Logging.apply { prepare { logger = Logger.DEFAULT level = LogLevel.ALL } } @Provides @Singleton fun provideKtorHttpClient( engine: HttpClientEngine, logging: Optional\u003cHttpClientFeature\u003cLogging.Config, Logging\u003e\u003e, ): HttpClient = HttpClient(engine) { expectSuccess = true logging.ifPresent { install(it) } install(JsonFeature) { serializer = KotlinxSerializer(kotlinx.serialization.json.Json { coerceInputValues = true ignoreUnknownKeys = true }) } } } } Dagger module 是用來向 Dagger 提供一些 Dagger 未能自動 instantiate 的 object。如果你有看過 Dagger 的教學，都是要在 class 的 constructor 加上 @Inject 然後在執行時那些寫在 constructor 的 parameter 就會自然地取得那些 object。這個自動找到 dependency 塞入去 constructor 給你用的動作就是 Dagger 幫你做的，但它那個自動功能只能 inject 其他在 constructor 加了 @Inject 的 class。但遇到其他 third party 的 class 例如 Ktor client 又或者是 Android SDK 入面的 ConnectivityManager 之類就要靠我們自己寫 Dagger module 來提示 Dagger 如何 instantiate 這些 class。@Provides 就是用來手動教 Dagger 如何 instantiate 那個 object。@Provides 的 function 名是不重要，因為 Dagger 只看 parameter type 和 return type，但習慣上都是會跟 annotation 名作前綴。@Provides function parameter 就是用來取得其他 dependency，例如 provideKtorHttpClient 需要用到 HttpClientEngine 和 HttpClientFeature 來 instantiate HttpClient。\n你或許會留意到第二個 parameter 被 Optional 包住，這個 Optional 是 Java 8 的東西，就是表示 HttpClientFeature 可能會有亦可能會無，有點像 nullable 的意思。因為那個被加註 @BindsOptionalOf 的 function，Dagger 能看懂 Optional。如果你全個 app 都沒有 @Provides 那個 logging feature 它亦不會 build fail。我把 logging 包了 Optional 是因為在 testing 或在 release build 時我們就不用為 HttpClient 加 logging。\n在 module 除了看到 @Module 之外，還有 @InstallIn(SingletonComponent::class)，這個 annotation 是 Hilt 的東西。Hilt 就是幫你訂好一個 Android app 會有那些 component。Component 主要作用是用來控制那些由 Dagger inject 的 dependency object 是不是在某範圍內重用還是每次要用到那個 dependency 都去 instantiate 一個新的。Hilt 的 SingletonComponent 就是跟 Application 共生死，它有對應的 scope 叫 @Singleton。上面 OkHttpClient 和 HttpClient 都加了 @Singleton，意思是如果那個 SingletonComponent 都是同一個 instance 的話，那我經那個 component 拿到的 OkHttpClient 和 HttpClient 都會是同一個 instance。正因為 Application 在執行時只會有一個 instance，所以 OkHttpClient 和 HttpClient 就變相成為平時我們理解的 singleton 一樣，只是不是用 object class 而是靠 Dagger 控制。而 OkHttpClient 和 HttpClient 要設成一個 app 共用同一個 instance 是因為 HTTP client 和 SQLite database connection 之類的東西建立成本比較高，所以不應每 call 一次 HTTP request 或 database query 都造一個全新的 connection。OkHttpClient 亦有同樣的提示：\nOkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a client for each request wastes resources on idle pools.\n最後有一樣東西或許大家有留意到就是 DataModule 是 interface，入面只放 @BindsOptionalOf function（還有日後的 @Binds function），而內裏的 companion object 就放了 @Provides 的 function。這是因為按照 Dagger 網站的說明 @Provides 最好是 static 而 @Binds 就因為 Dagger 會生成對應的 code，所以用 interface 就夠了。\nAnd for any module whose @Provides methods are all static, the implementation doesn’t need an instance at all.\n@Binds methods are a drop-in replacement for Provides methods that simply return an injected parameter. Prefer @Binds because the generated implementation is likely to be more efficient.\nUsing @Binds is the preferred way to define an alias because Dagger only needs the module at compile time, and can avoid class loading the module at runtime.\n我們已經準備好 Ktor client，下一篇我們會寫處理 backend API call 的部分。\n","wordCount":"2281","inLanguage":"zh-tw","datePublished":"2021-09-21T00:00:00+08:00","dateModified":"2021-09-21T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://eric.swiftzer.net/2021/09/2021-ithome-ironman-06-http-client/"},"publisher":{"@type":"Organization","name":"EricLog","logo":{"@type":"ImageObject","url":"https://eric.swiftzer.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://eric.swiftzer.net/ accesskey=h title="EricLog (Alt + H)">EricLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eric.swiftzer.net/fonts/ title=Fonts><span>Fonts</span></a></li><li><a href=https://eric.swiftzer.net/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://eric.swiftzer.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://eric.swiftzer.net/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://eric.swiftzer.net/>首頁</a>&nbsp;»&nbsp;<a href=https://eric.swiftzer.net/posts/>Posts</a></div><h1 class=post-title>2021 iThome 鐵人賽 Day 6：HTTP Client</h1><div class=post-meta><span title='2021-09-21 00:00:00 +0800 +0800'>September 21, 2021</span></div></header><div class=post-content><blockquote><p>本篇文章是 <a href=https://ithelp.ithome.com.tw/2021ironman>2021 iThome 鐵人賽</a>參賽題目「<a href=https://ithelp.ithome.com.tw/users/20139666/ironman/4661>寫一個列車抵站時間 Android App</a>」的第 6 篇，你可到 iThome <a href=https://ithelp.ithome.com.tw/articles/10268767>查看原文</a>。</p><p><a href=https://eric.swiftzer.net/2021-ithome-ironman/>文章目錄</a></p></blockquote><p>在 Android 開發如果要用到 HTTP client 的話基本上大家都預設用 <a href=https://square.github.io/okhttp/>OkHttp</a> + <a href=https://square.github.io/retrofit/>Retrofit</a> 這個組合。這次我們試試一些新東西：<a href=https://ktor.io/>Ktor</a>。</p><p>Ktor 是 JetBrains 出的 server library，就是用來開發 server side 的 web application。但它的功能比較簡單。不過我們不是用它的 server library，是用它的 client library。近年來 Kotlin 推廣用 Kotlin 寫跨平台應用（網頁、Android、iOS、backend），在 mobile app 那邊叫 Kotlin Multiplatform Mobile (KMM)，它就是要用 Kotlin 來寫 Android 和 iOS 共用的部分（通常就是 business logic、接駁 backend 那部分），至於 UI 的部分就各自用回該平台的方法寫。正因為共通的部分必須要用純 Kotlin 來寫，code 不能引用 Java Standard Library 的東西，所以 OkHttp 和 Retrofit 就不能直接在 KMM 上面用，取而代之就是 Ktor Client。</p><p>因應不同平台實際處理 HTTP request 的 client（Ktor 稱為 engine）各有不同，Ktor 把這些 HTTP client 封裝了一次。例如在 Android 可以用 OkHttp、CIO，在 iOS 就是用 <a href=https://developer.apple.com/documentation/foundation/nsurlsession><code>NSURLSession</code></a>。所以在建立 Ktor client 時要因應不同平台有不同的設定，但你調用 Ktor 的地方就不用加那些 <code>if (Android) { ... }</code> 的東西。</p><p>以下是我們這次會用到的 dependency：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-groovy data-lang=groovy><span class=line><span class=cl><span class=n>implementation</span> <span class=s2>&#34;io.ktor:ktor-client-core:$ktorVersion&#34;</span>
</span></span><span class=line><span class=cl><span class=n>implementation</span> <span class=s2>&#34;io.ktor:ktor-client-okhttp:$ktorVersion&#34;</span>
</span></span><span class=line><span class=cl><span class=n>implementation</span> <span class=s2>&#34;io.ktor:ktor-client-logging:$ktorVersion&#34;</span>
</span></span><span class=line><span class=cl><span class=n>implementation</span> <span class=s2>&#34;io.ktor:ktor-client-serialization:$ktorVersion&#34;</span>
</span></span><span class=line><span class=cl><span class=n>testImplementation</span> <span class=s2>&#34;io.ktor:ktor-client-mock:$ktorVersion&#34;</span>
</span></span><span class=line><span class=cl><span class=n>implementation</span> <span class=s2>&#34;com.squareup.okhttp3:okhttp:$okhttpVersion&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>implementation</span> <span class=s2>&#34;org.jetbrains.kotlinx:kotlinx-serialization-json:$kotlinSerializationVersion&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// logging the HTTP request and response
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>implementation</span> <span class=s2>&#34;org.slf4j:slf4j-api:$slf4jVersion&#34;</span>
</span></span><span class=line><span class=cl><span class=n>implementation</span> <span class=s2>&#34;com.github.tony19:logback-android:$logbackAndroidVersion&#34;</span>
</span></span></code></pre></div><h2 id=ktor-client-基本用法>Ktor Client 基本用法<a hidden class=anchor aria-hidden=true href=#ktor-client-基本用法>#</a></h2><p>如果我們甚麼都不理，只是單純用 Ktor client call API 的話，大概會是這樣：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>httpClient</span> <span class=p>=</span> <span class=n>HttpClient</span><span class=p>(</span><span class=n>OkHttp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>expectSuccess</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>    <span class=n>install</span><span class=p>(</span><span class=n>Logging</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>logger</span> <span class=p>=</span> <span class=n>Logger</span><span class=p>.</span><span class=n>DEFAULT</span>
</span></span><span class=line><span class=cl>        <span class=n>level</span> <span class=p>=</span> <span class=n>LogLevel</span><span class=p>.</span><span class=n>ALL</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>install</span><span class=p>(</span><span class=n>JsonFeature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>serializer</span> <span class=p>=</span> <span class=n>KotlinxSerializer</span><span class=p>(</span><span class=n>kotlinx</span><span class=p>.</span><span class=n>serialization</span><span class=p>.</span><span class=n>json</span><span class=p>.</span><span class=n>Json</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>coerceInputValues</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>            <span class=n>ignoreUnknownKeys</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>response</span><span class=p>:</span> <span class=n>EtaResponse</span> <span class=p>=</span> <span class=n>httpClient</span><span class=p>.</span><span class=k>get</span><span class=p>&lt;</span><span class=n>EtaResponse</span><span class=p>&gt;(</span><span class=s2>&#34;https://rt.data.gov.hk/v1/transport/mtr/getSchedule.php?line=TML&amp;sta=TIS&amp;lang=TC&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>設定 Ktor client 的寫法用了很多 lambda，就像那些 <em>build.gradle</em> 般做了專門而設的 DSL。上面的 HTTP client 設定就是幫它加了 logging 和用 Kotlin Serialization 做 JSON deserialization。</p><p>然後發送 HTTP request 就是簡單一句 <code>httpClient.get&lt;EtaResponse></code> 就能拿到 deserialize 好的 response data class object。</p><p>如果見到網址有一大串 query parameter 感覺不爽的話，可以寫成這樣：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>httpClient</span><span class=p>.</span><span class=k>get</span><span class=p>&lt;</span><span class=n>EtaResponse</span><span class=p>&gt;(</span><span class=s2>&#34;https://rt.data.gov.hk/v1/transport/mtr/getSchedule.php&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>parameter</span><span class=p>(</span><span class=s2>&#34;line&#34;</span><span class=p>,</span> <span class=s2>&#34;TML&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>parameter</span><span class=p>(</span><span class=s2>&#34;sta&#34;</span><span class=p>,</span> <span class=s2>&#34;TIS&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>parameter</span><span class=p>(</span><span class=s2>&#34;lang&#34;</span><span class=p>,</span> <span class=s2>&#34;TC&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>這個 <code>httpClient.get</code> 是 suspending function，IDE 會在 suspending function 的行數顯示箭頭型的 <a href=https://www.jetbrains.com/help/idea/settings-gutter-icons.html>gutter icon</a> 作提示。Suspending function 要有 Coroutine scope 包住才能用，以 <code>Activity</code> 為例，你不能在 <code>onCreate</code> 內 call 這一句，因為 <code>onCreate</code> 不是 suspending function，只有在 suspending function 內才能 call 另一個 suspending function，或者是在 coroutine scope 內。簡單來講，coroutine scope 就是用來連接 coroutine 和非 coroutine 的地方，coroutine scope 另一個用途是用來一併停止未完結的 suspending function，例如 <code>onDestroy</code> 時就可以 call coroutine scope 的 <code>cancel</code>。這個意念跟 RxJava 的 <code>CompositeDisposable</code> 類似。其實現在 AndroidX 的 library 已經幫我們在 <code>Activity</code>、<code>Fragment</code>、<code>ViewModel</code> 等地方為我們造好了對應其 lifecycle 的 coroutine scope，我們只需要直接調用就可以了，詳細的內容我們之後會示範。</p><h2 id=dagger-設定>Dagger 設定<a hidden class=anchor aria-hidden=true href=#dagger-設定>#</a></h2><p>看過基本用法後我們要把 Ktor client 的設置放到 Dagger module 入面，這樣就可以經 Dagger 取得 Ktor client 的 instance。以下是大約的寫法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Module</span>
</span></span><span class=line><span class=cl><span class=nd>@InstallIn</span><span class=p>(</span><span class=n>SingletonComponent</span><span class=o>::</span><span class=k>class</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>interface</span> <span class=nc>DataModule</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@BindsOptionalOf</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>bindLogging</span><span class=p>():</span> <span class=n>HttpClientFeature</span><span class=p>&lt;</span><span class=n>Logging</span><span class=p>.</span><span class=n>Config</span><span class=p>,</span> <span class=n>Logging</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>companion</span> <span class=k>object</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Provides</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Singleton</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>provideOkHttpClient</span><span class=p>():</span> <span class=n>OkHttpClient</span> <span class=p>=</span> <span class=n>OkHttpClient</span><span class=p>.</span><span class=n>Builder</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>build</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@Provides</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>provideHttpClientEngine</span><span class=p>(</span><span class=n>okHttpClient</span><span class=p>:</span> <span class=n>OkHttpClient</span><span class=p>):</span> <span class=n>HttpClientEngine</span> <span class=p>=</span> <span class=n>OkHttp</span><span class=p>.</span><span class=n>create</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>preconfigured</span> <span class=p>=</span> <span class=n>okHttpClient</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@Provides</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>provideLogging</span><span class=p>():</span> <span class=n>HttpClientFeature</span><span class=p>&lt;</span><span class=n>Logging</span><span class=p>.</span><span class=n>Config</span><span class=p>,</span> <span class=n>Logging</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>Logging</span><span class=p>.</span><span class=n>apply</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>prepare</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>logger</span> <span class=p>=</span> <span class=n>Logger</span><span class=p>.</span><span class=n>DEFAULT</span>
</span></span><span class=line><span class=cl>                <span class=n>level</span> <span class=p>=</span> <span class=n>LogLevel</span><span class=p>.</span><span class=n>ALL</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@Provides</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Singleton</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>provideKtorHttpClient</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>engine</span><span class=p>:</span> <span class=n>HttpClientEngine</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=p>:</span> <span class=n>Optional</span><span class=p>&lt;</span><span class=n>HttpClientFeature</span><span class=p>&lt;</span><span class=n>Logging</span><span class=p>.</span><span class=n>Config</span><span class=p>,</span> <span class=n>Logging</span><span class=p>&gt;&gt;,</span>
</span></span><span class=line><span class=cl>        <span class=p>):</span> <span class=n>HttpClient</span> <span class=p>=</span> <span class=n>HttpClient</span><span class=p>(</span><span class=n>engine</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>expectSuccess</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=p>.</span><span class=n>ifPresent</span> <span class=p>{</span> <span class=n>install</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>install</span><span class=p>(</span><span class=n>JsonFeature</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>serializer</span> <span class=p>=</span> <span class=n>KotlinxSerializer</span><span class=p>(</span><span class=n>kotlinx</span><span class=p>.</span><span class=n>serialization</span><span class=p>.</span><span class=n>json</span><span class=p>.</span><span class=n>Json</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>coerceInputValues</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>                    <span class=n>ignoreUnknownKeys</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>                <span class=p>})</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Dagger module 是用來向 Dagger 提供一些 Dagger 未能自動 instantiate 的 object。如果你有看過 Dagger 的教學，都是要在 class 的 constructor 加上 <code>@Inject</code> 然後在執行時那些寫在 constructor 的 parameter 就會自然地取得那些 object。這個自動找到 dependency 塞入去 constructor 給你用的動作就是 Dagger 幫你做的，但它那個自動功能只能 inject 其他在 constructor 加了 <code>@Inject</code> 的 class。但遇到其他 third party 的 class 例如 Ktor client 又或者是 Android SDK 入面的 <code>ConnectivityManager</code> 之類就要靠我們自己寫 Dagger module 來提示 Dagger 如何 instantiate 這些 class。<code>@Provides</code> 就是用來手動教 Dagger 如何 instantiate 那個 object。<code>@Provides</code> 的 function 名是不重要，因為 Dagger 只看 parameter type 和 return type，但習慣上都是會跟 annotation 名作前綴。<code>@Provides</code> function parameter 就是用來取得其他 dependency，例如 <code>provideKtorHttpClient</code> 需要用到 <code>HttpClientEngine</code> 和 <code>HttpClientFeature&lt;Logging.Config, Logging></code> 來 instantiate <code>HttpClient</code>。</p><p>你或許會留意到第二個 parameter 被 <code>Optional</code> 包住，這個 <code>Optional</code> 是 Java 8 的東西，就是表示 <code>HttpClientFeature&lt;Logging.Config, Logging></code> 可能會有亦可能會無，有點像 nullable 的意思。因為那個被加註 <code>@BindsOptionalOf</code> 的 function，Dagger 能看懂 <code>Optional</code>。如果你全個 app 都沒有 <code>@Provides</code> 那個 logging feature 它亦不會 build fail。我把 logging 包了 <code>Optional</code> 是因為在 testing 或在 release build 時我們就不用為 <code>HttpClient</code> 加 logging。</p><p>在 module 除了看到 <code>@Module</code> 之外，還有 <code>@InstallIn(SingletonComponent::class)</code>，這個 annotation 是 Hilt 的東西。Hilt 就是幫你訂好一個 Android app 會有那些 component。Component 主要作用是用來控制那些由 Dagger inject 的 dependency object 是不是在某範圍內重用還是每次要用到那個 dependency 都去 instantiate 一個新的。Hilt 的 <code>SingletonComponent</code> 就是跟 <code>Application</code> 共生死，它有對應的 scope 叫 <code>@Singleton</code>。上面 <code>OkHttpClient</code> 和 <code>HttpClient</code> 都加了 <code>@Singleton</code>，意思是如果那個 <code>SingletonComponent</code> 都是同一個 instance 的話，那我經那個 component 拿到的 <code>OkHttpClient</code> 和 <code>HttpClient</code> 都會是同一個 instance。正因為 <code>Application</code> 在執行時只會有一個 instance，所以 <code>OkHttpClient</code> 和 <code>HttpClient</code> 就變相成為平時我們理解的 singleton 一樣，只是不是用 object class 而是靠 Dagger 控制。而 <code>OkHttpClient</code> 和 <code>HttpClient</code> 要設成一個 app 共用同一個 instance 是因為 HTTP client 和 SQLite database connection 之類的東西建立成本比較高，所以不應每 call 一次 HTTP request 或 database query 都造一個全新的 connection。<a href=https://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/><code>OkHttpClient</code></a> 亦有同樣的提示：</p><blockquote><p>OkHttp performs best when you create a single <code>OkHttpClient</code> instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a client for each request wastes resources on idle pools.</p></blockquote><p>最後有一樣東西或許大家有留意到就是 <code>DataModule</code> 是 interface，入面只放 <code>@BindsOptionalOf</code> function（還有日後的 <code>@Binds</code> function），而內裏的 companion object 就放了 <code>@Provides</code> 的 function。這是因為按照 <a href=https://dagger.dev/dev-guide/>Dagger 網站的說明</a> <code>@Provides</code> 最好是 static 而 <code>@Binds</code> 就因為 <a href=https://dagger.dev/api/latest/dagger/Binds.html>Dagger 會生成對應的 code</a>，所以用 interface 就夠了。</p><blockquote><p>And for any module whose <code>@Provides</code> methods are all static, the implementation doesn&rsquo;t need an instance at all.</p></blockquote><blockquote><p><code>@Binds</code> methods are a drop-in replacement for <code>Provides</code> methods that simply return an injected parameter. Prefer <code>@Binds</code> because the generated implementation is likely to be more efficient.</p></blockquote><blockquote><p>Using <code>@Binds</code> is the preferred way to define an alias because Dagger only needs the module at compile time, and can avoid class loading the module at runtime.</p></blockquote><p>我們已經準備好 Ktor client，下一篇我們會寫處理 backend API call 的部分。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://eric.swiftzer.net/tags/2021-ithome-%E9%90%B5%E4%BA%BA%E8%B3%BD/>2021 iThome 鐵人賽</a></li><li><a href=https://eric.swiftzer.net/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=https://eric.swiftzer.net/2021/09/2021-ithome-ironman-07-data-layer-implementation-1/><span class=title>« 上一頁</span><br><span>2021 iThome 鐵人賽 Day 7：Data layer implementation (1)</span></a>
<a class=next href=https://eric.swiftzer.net/2021/09/2021-ithome-ironman-05-dependency-injection/><span class=title>下一頁 »</span><br><span>2021 iThome 鐵人賽 Day 5：Dependency injection</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//efilm.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://eric.swiftzer.net/>EricLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>