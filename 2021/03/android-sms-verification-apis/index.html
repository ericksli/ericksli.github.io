<!doctype html><html lang=zh-hant-hk dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Android SMS Verification APIs | EricLog</title>
<meta name=keywords content="Android">
<meta name=description content="SMS 驗證應該是一個在 Android app 頗為常見的需求。一般做法都是先讓用戶填寫電話號碼，然後 app 會把電話號碼交到 backend 再透過 SMS gateway 發送含有驗證碼短訊， 當用戶收到 SMS 後">
<meta name=author content>
<link rel=canonical href=https://eric.swiftzer.net/2021/03/android-sms-verification-apis/>
<link href=/assets/css/stylesheet.min.d1fc837a267f77f6ede89d1a89c4880a90c381d9e6673ad4a76a3ad1900b65f9.css integrity="sha256-0fyDeiZ/d/bt6J0aicSICpDDgdnmZzrUp2o60ZALZfk=" rel="preload stylesheet" as=style>
<link rel=icon href=https://eric.swiftzer.net/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://eric.swiftzer.net/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://eric.swiftzer.net/favicon-32x32.png>
<link rel=apple-touch-icon href=https://eric.swiftzer.net/apple-touch-icon.png>
<link rel=mask-icon href=https://eric.swiftzer.net/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=preconnect href=https://fonts.gstatic.com>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@300&display=swap" rel=stylesheet>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-1268728-8','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="Android SMS Verification APIs">
<meta property="og:description" content="SMS 驗證應該是一個在 Android app 頗為常見的需求。一般做法都是先讓用戶填寫電話號碼，然後 app 會把電話號碼交到 backend 再透過 SMS gateway 發送含有驗證碼短訊， 當用戶收到 SMS 後">
<meta property="og:type" content="article">
<meta property="og:url" content="https://eric.swiftzer.net/2021/03/android-sms-verification-apis/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-03-14T22:20:00+08:00">
<meta property="article:modified_time" content="2021-03-14T22:20:00+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Android SMS Verification APIs">
<meta name=twitter:description content="SMS 驗證應該是一個在 Android app 頗為常見的需求。一般做法都是先讓用戶填寫電話號碼，然後 app 會把電話號碼交到 backend 再透過 SMS gateway 發送含有驗證碼短訊， 當用戶收到 SMS 後">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://eric.swiftzer.net/posts/"},{"@type":"ListItem","position":2,"name":"Android SMS Verification APIs","item":"https://eric.swiftzer.net/2021/03/android-sms-verification-apis/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android SMS Verification APIs","name":"Android SMS Verification APIs","description":"SMS 驗證應該是一個在 Android app 頗為常見的需求。一般做法都是先讓用戶填寫電話號碼，然後 app 會把電話號碼交到 backend 再透過 SMS gateway 發送含有驗證碼短訊， 當用戶收到 SMS 後","keywords":["Android"],"articleBody":"SMS 驗證應該是一個在 Android app 頗為常見的需求。一般做法都是先讓用戶填寫電話號碼，然後 app 會把電話號碼交到 backend 再透過 SMS gateway 發送含有驗證碼短訊， 當用戶收到 SMS 後再把內文的驗證碼輸入到 app 中。如果想省卻用戶輪入文字的話有一些 app 會透過 READ_SMS 權限讀取 SMS 內容來抽取驗證碼，但 Google Play 已經限制非預設短訊 app 不可以有 READ_SMS 權限。\nSMS Retriever API 如果有留意過一些 app 的驗證 SMS 的話，可以發現到有一些 SMS 內文結尾會加插一些英數字符。\n  SMS Retriever 短訊例子   當系統這種 SMS 後 app 就能自動填入那個 SMS 內的驗證碼，但特別的是那些 app 並沒有要求 READ_SMS 權限。其實它們是用了 Google 的 SMS Retriever APIs。簡單來講，就是 Google Play Services 代你的 app 拿了 READ_SMS 權限，由 Google Play Services 中央處理那些讀取 SMS 驗證碼的權限處理。最尾那一串英數字符就是給 Google Play Services 判斷這個 SMS 是要交到那個 app 處理。\n其實 SMS Retriever API 用法其實不太複雜，大概步驟就是：\n Backend 發送 SMS 時在內文結尾加上一個特有的英數字符 app 通知 SMS Retriever 開始監測系統接收到的 SMS SMS Retriever 接收到 SMS 後按照末端的英數字符通知對應的 app，app 透過 BroadcastReceiver 接收 SMS 內文，從中抽取驗證碼並繼續流程  SMS 內容 按照說明文檔，SMS 不能大過 140 bytes 和包含一個 11 位長的英數字符。那個英數字符是用 app 的 keystore 加上 application ID 生成出來，除了透過 shell script 生成之外，Google 還留了一個 AppSignatureHelper 方便大家生成那個字串。\n先前的 SMS 例子開首有個 ，這其實是用來表示這個 SMS 是這是一個提供一次性密碼的 SMS。但現在 SMS Retriever 已經沒有這個規定。\n開始監測 要觸發 SMS Retriever 開始監測收到的 SMS，只需要 call SmsRetriever 的 startSmsRetriever 就可以了，監測期為五分鐘。1 下面的例子用了 kotlinx-coroutines-play-services 的 await 把原本 Google Play Services 的 Tasks API 變成 coroutine。2 緊記在通知 backend 發送時馬上通知 SMS Retriever，否則 SMS Retriever 就趕不來截取那個 SMS。\nimport com.google.android.gms.auth.api.phone.SmsRetriever import kotlinx.coroutines.tasks.await suspend fun startSmsRetriever() { val client = SmsRetriever.getClient(context) client.startSmsRetriever().await() } 不要忘記加入 Google Play Services auth component（最新版本請查 Google’s Maven Repository）\nimplementation 'com.google.android.gms:play-services-auth:17.0.0' implementation 'com.google.android.gms:play-services-auth-api-phone:17.4.0' 讀取驗證碼 當裝置收到 SMS 後，SMS Retriever 就會透過 BroadcastReceiver 通知對應的 app。在 BroadcastReceiver 入面可以透過 SmsRetriever.EXTRA_SMS_MESSAGE 取得該 SMS 內文。之後就可以用 regular expression 之類的方法抽取驗證碼，再通知 UI 填寫驗證碼繼續流程。\nclass SmsRetrieverBroadcastReceiver : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { if (SmsRetriever.SMS_RETRIEVED_ACTION == intent.action) { val status = intent.extras?.get(SmsRetriever.EXTRA_STATUS) as Status? when (status?.statusCode) { CommonStatusCodes.SUCCESS - { // Success, obtain the SMS message body  val message = intent.extras ?.getString(SmsRetriever.EXTRA_SMS_MESSAGE) .orEmpty() } CommonStatusCodes.TIMEOUT - { // Error  } } } } } 因為加了 BroadcastReceiver，所以要在 AndroidManifest.xml 加上  tag：\n xmlns:android=\"http://schemas.android.com/apk/res/android\"   android:name=\".SmsRetrieverBroadcastReceiver\" android:exported=\"true\" android:permission=\"com.google.android.gms.auth.api.phone.permission.SEND\"   android:name=\"com.google.android.gms.auth.api.phone.SMS_RETRIEVED\" /     SMS User Consent API 上面介紹的 SMS Retriever API 只適用於能夠控制到 SMS 內文的情況。但如果那個 SMS 並不能自己控制內文的話（例如由銀行發出），那就要使用 SMS User Consent API。做法和 SMS Retriever API 相似，最大分別是系統會顯示一個 bottom sheet 詢問用戶是不是想把收到的那個 SMS 給予 app 讀取。如果同意的話 app 就會透過 BroadcastReceiver 接收 SMS 原文。\n延伸閱讀  Is Apple moving to standardize the SMS OTP format? Origin-bound one-time codes delivered via SMS     SmsRetrieverApi#startSmsRetriever: Starts SmsRetriever, which waits for a matching SMS message until timeout (5 minutes). ↩︎\n kotlinx-coroutines-play-services 的 group 和 artifact 名稱是 org.jetbrains.kotlinx:kotlinx-coroutines-play-services。 ↩︎\n   ","wordCount":"1171","inLanguage":"en","datePublished":"2021-03-14T22:20:00+08:00","dateModified":"2021-03-14T22:20:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://eric.swiftzer.net/2021/03/android-sms-verification-apis/"},"publisher":{"@type":"Organization","name":"EricLog","logo":{"@type":"ImageObject","url":"https://eric.swiftzer.net/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://eric.swiftzer.net/ accesskey=h title="EricLog (Alt + H)">EricLog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://eric.swiftzer.net/fonts/ title=Fonts>
<span>Fonts</span>
</a>
</li>
<li>
<a href=https://eric.swiftzer.net/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://eric.swiftzer.net/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://eric.swiftzer.net/about/ title=About>
<span>About</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Android SMS Verification APIs
</h1>
<div class=post-meta>March 14, 2021
</div>
</header>
<div class=post-content>
<p>SMS 驗證應該是一個在 Android app 頗為常見的需求。一般做法都是先讓用戶填寫電話號碼，然後 app 會把電話號碼交到 backend 再透過 SMS gateway 發送含有驗證碼短訊，
當用戶收到 SMS 後再把內文的驗證碼輸入到 app 中。如果想省卻用戶輪入文字的話有一些 app 會透過 <code>READ_SMS</code> 權限讀取 SMS 內容來抽取驗證碼，但 Google Play 已經<a href=https://support.google.com/googleplay/android-developer/answer/10208820>限制非預設短訊 app
不可以有 <code>READ_SMS</code> 權限</a>。</p>
<h2 id=sms-retriever-api>SMS Retriever API<a hidden class=anchor aria-hidden=true href=#sms-retriever-api>#</a></h2>
<p>如果有留意過一些 app 的驗證 SMS 的話，可以發現到有一些 SMS 內文結尾會加插一些英數字符。</p>
<figure>
<img loading=lazy src=sms-retriever-sample.png> <figcaption>
SMS Retriever 短訊例子
</figcaption>
</figure>
<p>當系統這種 SMS 後 app 就能自動填入那個 SMS 內的驗證碼，但特別的是那些 app 並沒有要求 <code>READ_SMS</code> 權限。其實它們是用了 Google 的 <a href=https://developers.google.com/identity/sms-retriever/overview>SMS Retriever APIs</a>。簡單來講，就是 Google Play Services 代你的 app 拿了 <code>READ_SMS</code> 權限，由 Google Play Services 中央處理那些讀取 SMS 驗證碼的權限處理。最尾那一串英數字符就是給 Google Play Services 判斷這個 SMS 是要交到那個 app 處理。</p>
<p>其實 SMS Retriever API 用法其實不太複雜，大概步驟就是：</p>
<ol>
<li>Backend 發送 SMS 時在內文結尾加上一個特有的英數字符</li>
<li>app 通知 SMS Retriever 開始監測系統接收到的 SMS</li>
<li>SMS Retriever 接收到 SMS 後按照末端的英數字符通知對應的 app，app 透過 <code>BroadcastReceiver</code> 接收 SMS 內文，從中抽取驗證碼並繼續流程</li>
</ol>
<h3 id=sms-內容>SMS 內容<a hidden class=anchor aria-hidden=true href=#sms-內容>#</a></h3>
<p>按照<a href=https://developers.google.com/identity/sms-retriever/verify>說明文檔</a>，SMS 不能大過 140 bytes 和包含一個 11 位長的英數字符。那個英數字符是用 app 的 keystore 加上 application ID 生成出來，除了透過 <a href=https://github.com/googlearchive/android-credentials/blob/master/sms-verification/bin/sms_retriever_hash_v9.sh>shell script</a> 生成之外，Google 還留了一個 <a href=https://github.com/googlearchive/android-credentials/blob/master/sms-verification/android/app/src/main/java/com/google/samples/smartlock/sms_verify/AppSignatureHelper.java><code>AppSignatureHelper</code></a> 方便大家生成那個字串。</p>
<p>先前的 SMS 例子開首有個 <code>&lt;#></code>，這其實是用來表示這個 SMS 是這是一個提供一次性密碼的 SMS。但現在 SMS Retriever 已經沒有這個規定。</p>
<h3 id=開始監測>開始監測<a hidden class=anchor aria-hidden=true href=#開始監測>#</a></h3>
<p>要觸發 SMS Retriever 開始監測收到的 SMS，只需要 call <code>SmsRetriever</code> 的 <code>startSmsRetriever</code> 就可以了，監測期為五分鐘。<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> 下面的例子用了 <a href=https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-play-services>kotlinx-coroutines-play-services</a> 的 <code>await</code> 把原本 Google Play Services 的 <a href=https://developers.google.com/android/guides/tasks>Tasks API</a> 變成 coroutine。<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 緊記在通知 backend 發送時馬上通知 SMS Retriever，否則 SMS Retriever 就趕不來截取那個 SMS。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>import</span> <span class=nn>com.google.android.gms.auth.api.phone.SmsRetriever</span>
<span class=k>import</span> <span class=nn>kotlinx.coroutines.tasks.await</span>

<span class=k>suspend</span> <span class=k>fun</span> <span class=nf>startSmsRetriever</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>val</span> <span class=py>client</span> <span class=p>=</span> <span class=n>SmsRetriever</span><span class=p>.</span><span class=n>getClient</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>
    <span class=n>client</span><span class=p>.</span><span class=n>startSmsRetriever</span><span class=p>().</span><span class=n>await</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></div><p>不要忘記加入 Google Play Services auth component（最新版本請查 <a href=https://maven.google.com/web/index.html>Google&rsquo;s Maven Repository</a>）</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-groovy data-lang=groovy><span class=n>implementation</span> <span class=s1>&#39;com.google.android.gms:play-services-auth:17.0.0&#39;</span>
<span class=n>implementation</span> <span class=s1>&#39;com.google.android.gms:play-services-auth-api-phone:17.4.0&#39;</span>
</code></pre></div><h3 id=讀取驗證碼>讀取驗證碼<a hidden class=anchor aria-hidden=true href=#讀取驗證碼>#</a></h3>
<p>當裝置收到 SMS 後，SMS Retriever 就會透過 <code>BroadcastReceiver</code> 通知對應的 app。在 <code>BroadcastReceiver</code> 入面可以透過 <code>SmsRetriever.EXTRA_SMS_MESSAGE</code> 取得該 SMS 內文。之後就可以用 regular expression 之類的方法抽取驗證碼，再通知 UI 填寫驗證碼繼續流程。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>class</span> <span class=nc>SmsRetrieverBroadcastReceiver</span> <span class=p>:</span> <span class=n>BroadcastReceiver</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onReceive</span><span class=p>(</span><span class=n>context</span><span class=p>:</span> <span class=n>Context</span><span class=p>,</span> <span class=n>intent</span><span class=p>:</span> <span class=n>Intent</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>SmsRetriever</span><span class=p>.</span><span class=n>SMS_RETRIEVED_ACTION</span> <span class=o>==</span> <span class=n>intent</span><span class=p>.</span><span class=n>action</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>val</span> <span class=py>status</span> <span class=p>=</span> <span class=n>intent</span><span class=p>.</span><span class=n>extras</span><span class=o>?.</span><span class=k>get</span><span class=p>(</span><span class=n>SmsRetriever</span><span class=p>.</span><span class=n>EXTRA_STATUS</span><span class=p>)</span> <span class=k>as</span> <span class=n>Status</span><span class=p>?</span>
            <span class=k>when</span> <span class=p>(</span><span class=n>status</span><span class=o>?.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>CommonStatusCodes</span><span class=p>.</span><span class=n>SUCCESS</span> <span class=o>-&gt;</span> <span class=p>{</span>
                    <span class=c1>// Success, obtain the SMS message body
</span><span class=c1></span>                    <span class=k>val</span> <span class=py>message</span> <span class=p>=</span> <span class=n>intent</span><span class=p>.</span><span class=n>extras</span>
                            <span class=o>?.</span><span class=n>getString</span><span class=p>(</span><span class=n>SmsRetriever</span><span class=p>.</span><span class=n>EXTRA_SMS_MESSAGE</span><span class=p>)</span>
                            <span class=p>.</span><span class=n>orEmpty</span><span class=p>()</span>
                <span class=p>}</span>
                <span class=n>CommonStatusCodes</span><span class=p>.</span><span class=n>TIMEOUT</span> <span class=o>-&gt;</span> <span class=p>{</span>
                    <span class=c1>// Error
</span><span class=c1></span>                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>因為加了 <code>BroadcastReceiver</code>，所以要在 <em>AndroidManifest.xml</em> 加上 <code>&lt;receiver></code> tag：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=nt>&lt;manifest</span> <span class=na>xmlns:android=</span><span class=s>&#34;http://schemas.android.com/apk/res/android&#34;</span><span class=nt>&gt;</span>
    <span class=nt>&lt;application&gt;</span>
        <span class=nt>&lt;receiver</span>
            <span class=na>android:name=</span><span class=s>&#34;.SmsRetrieverBroadcastReceiver&#34;</span>
            <span class=na>android:exported=</span><span class=s>&#34;true&#34;</span>
            <span class=na>android:permission=</span><span class=s>&#34;com.google.android.gms.auth.api.phone.permission.SEND&#34;</span><span class=nt>&gt;</span>
            <span class=nt>&lt;intent-filter&gt;</span>
                <span class=nt>&lt;action</span> <span class=na>android:name=</span><span class=s>&#34;com.google.android.gms.auth.api.phone.SMS_RETRIEVED&#34;</span> <span class=nt>/&gt;</span>
            <span class=nt>&lt;/intent-filter&gt;</span>
        <span class=nt>&lt;/receiver&gt;</span>
    <span class=nt>&lt;/application&gt;</span>
<span class=nt>&lt;/manifest&gt;</span>
</code></pre></div><h2 id=sms-user-consent-api>SMS User Consent API<a hidden class=anchor aria-hidden=true href=#sms-user-consent-api>#</a></h2>
<p>上面介紹的 SMS Retriever API 只適用於能夠控制到 SMS 內文的情況。但如果那個 SMS 並不能自己控制內文的話（例如由銀行發出），那就要使用 <a href=https://developers.google.com/identity/sms-retriever/user-consent/overview>SMS User Consent API</a>。做法和 SMS Retriever API 相似，最大分別是系統會顯示一個 bottom sheet 詢問用戶是不是想把收到的那個 SMS 給予 app 讀取。如果同意的話 app 就會透過 <code>BroadcastReceiver</code> 接收 SMS 原文。</p>
<h2 id=延伸閱讀>延伸閱讀<a hidden class=anchor aria-hidden=true href=#延伸閱讀>#</a></h2>
<ul>
<li><a href=https://www.smsglobal.com/blog/standard-otp-format/>Is Apple moving to standardize the SMS OTP format?</a></li>
<li><a href=https://wicg.github.io/sms-one-time-codes/>Origin-bound one-time codes delivered via SMS
</a></li>
</ul>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p><a href=https://developers.google.com/android/reference/com/google/android/gms/auth/api/phone/SmsRetrieverApi#startSmsRetriever()><code>SmsRetrieverApi#startSmsRetriever</code></a>: Starts <code>SmsRetriever</code>, which waits for a matching SMS message until timeout (5 minutes).&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p>kotlinx-coroutines-play-services 的 group 和 artifact 名稱是 <code>org.jetbrains.kotlinx:kotlinx-coroutines-play-services</code>。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://eric.swiftzer.net/tags/android/>Android</a></li>
</ul>
</footer><div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//efilm.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://eric.swiftzer.net/>EricLog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>