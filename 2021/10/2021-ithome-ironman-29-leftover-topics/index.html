<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2021 iThome 鐵人賽 Day 29：Leftover topics | EricLog</title><meta name=keywords content="2021 iThome 鐵人賽,Android"><meta name=description content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 29 篇，你可到 iThome 查看原文。 文章目錄 我們終於來到第廿九篇，我們這次討論的題目都是之"><meta name=author content><link rel=canonical href=https://ithelp.ithome.com.tw/articles/10281516><link crossorigin=anonymous href=/assets/css/stylesheet.min.249b1770ac429c01ffa746cc012a310192d174c913b1527f312e3294a0766d1c.css integrity="sha256-JJsXcKxCnAH/p0bMASoxAZLRdMkTsVJ/MS4ylKB2bRw=" rel="preload stylesheet" as=style><link rel=icon href=https://eric.swiftzer.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://eric.swiftzer.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://eric.swiftzer.net/favicon-32x32.png><link rel=apple-touch-icon href=https://eric.swiftzer.net/apple-touch-icon.png><link rel=mask-icon href=https://eric.swiftzer.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@300&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-D93F946T73"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D93F946T73",{anonymize_ip:!1})}</script><meta property="og:title" content="2021 iThome 鐵人賽 Day 29：Leftover topics"><meta property="og:description" content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 29 篇，你可到 iThome 查看原文。 文章目錄 我們終於來到第廿九篇，我們這次討論的題目都是之"><meta property="og:type" content="article"><meta property="og:url" content="https://eric.swiftzer.net/2021/10/2021-ithome-ironman-29-leftover-topics/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-14T00:00:00+08:00"><meta property="article:modified_time" content="2021-10-14T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="2021 iThome 鐵人賽 Day 29：Leftover topics"><meta name=twitter:description content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 29 篇，你可到 iThome 查看原文。 文章目錄 我們終於來到第廿九篇，我們這次討論的題目都是之"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://eric.swiftzer.net/posts/"},{"@type":"ListItem","position":2,"name":"2021 iThome 鐵人賽 Day 29：Leftover topics","item":"https://eric.swiftzer.net/2021/10/2021-ithome-ironman-29-leftover-topics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2021 iThome 鐵人賽 Day 29：Leftover topics","name":"2021 iThome 鐵人賽 Day 29：Leftover topics","description":"本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 29 篇，你可到 iThome 查看原文。 文章目錄 我們終於來到第廿九篇，我們這次討論的題目都是之","keywords":["2021 iThome 鐵人賽","Android"],"articleBody":" 本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 29 篇，你可到 iThome 查看原文。\n文章目錄\n我們終於來到第廿九篇，我們這次討論的題目都是之前討論過的東西的延伸。因為篇幅和時間有限就只好把它們合併成一篇。\nTwo-way data binding 我們在示範 app 一直都是在用 one-way data binding，只要在 layout XML 加上 @{ ... } 就能用到 LiveData 或 StateFlow 的值，並且能在 LiveData 或 StateFlow 的值改動時自動更新 UI（要設定好 LifecycleOwner）。Two-way data binding 適合在一些用戶輸入的 UI 組件使用，例如 TextEdit、CheckBox 之類。寫法會是這樣：\n","wordCount":"4215","inLanguage":"zh-tw","datePublished":"2021-10-14T00:00:00+08:00","dateModified":"2021-10-14T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://eric.swiftzer.net/2021/10/2021-ithome-ironman-29-leftover-topics/"},"publisher":{"@type":"Organization","name":"EricLog","logo":{"@type":"ImageObject","url":"https://eric.swiftzer.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://eric.swiftzer.net/ accesskey=h title="EricLog (Alt + H)">EricLog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://eric.swiftzer.net/fonts/ title=Fonts><span>Fonts</span></a></li><li><a href=https://eric.swiftzer.net/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://eric.swiftzer.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://eric.swiftzer.net/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://eric.swiftzer.net/>首頁</a>&nbsp;»&nbsp;<a href=https://eric.swiftzer.net/posts/>Posts</a></div><h1 class=post-title>2021 iThome 鐵人賽 Day 29：Leftover topics</h1><div class=post-meta>October 14, 2021</div></header><div class=post-content><blockquote><p>本篇文章是 <a href=https://ithelp.ithome.com.tw/2021ironman>2021 iThome 鐵人賽</a>參賽題目「<a href=https://ithelp.ithome.com.tw/users/20139666/ironman/4661>寫一個列車抵站時間 Android App</a>」的第 29 篇，你可到 iThome <a href=https://ithelp.ithome.com.tw/articles/10281516>查看原文</a>。</p><p><a href=https://eric.swiftzer.net/2021-ithome-ironman/>文章目錄</a></p></blockquote><p>我們終於來到第廿九篇，我們這次討論的題目都是之前討論過的東西的延伸。因為篇幅和時間有限就只好把它們合併成一篇。</p><h2 id=two-way-data-binding>Two-way data binding<a hidden class=anchor aria-hidden=true href=#two-way-data-binding>#</a></h2><p>我們在示範 app 一直都是在用 one-way data binding，只要在 layout XML 加上 <code>@{ ... }</code> 就能用到 <code>LiveData</code> 或 <code>StateFlow</code> 的值，並且能在 <code>LiveData</code> 或 <code>StateFlow</code> 的值改動時自動更新 UI（要設定好 <code>LifecycleOwner</code>）。Two-way data binding 適合在一些用戶輸入的 UI 組件使用，例如 <code>TextEdit</code>、<code>CheckBox</code> 之類。寫法會是這樣：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;EditText</span>
</span></span><span class=line><span class=cl>    <span class=na>android:layout_width=</span><span class=s>&#34;wrap_content&#34;</span>
</span></span><span class=line><span class=cl>    <span class=na>android:layout_height=</span><span class=s>&#34;wrap_content&#34;</span>
</span></span><span class=line><span class=cl>    <span class=na>android:text=</span><span class=s>&#34;@={viewModel.query}&#34;</span> <span class=nt>/&gt;</span>
</span></span></code></pre></div><p><code>query</code> 可以是 <code>MutableLiveData</code> 或 <code>MutableStateFlow</code>。留意是要用 mutable 的，因為當用戶改變 <code>EditText</code> 的值時會直接把最新的值寫入去 <code>MutableLiveData</code> 或 <code>MutableStateFlow</code>。然後你可以在 <code>ViewModel</code> 把那個 <code>MutableLiveData</code> 或 <code>MutableStateFlow</code> 用 <code>map</code> 之類的 operator 轉化成其他動作（例如當用戶在輸入文字後就 call API 搜尋內容）。</p><p>其實 data binding 的原理是那些 <code>@{ ... }</code> 和 <code>@={ ... }</code> 語法會在 compile 時轉成 binding 的 class，入面還是會 call 那些 view 的 getter、setter、listener，只是不用我們自己寫而已。這樣就可以少寫一部分 code。</p><p>但 data binding 還是有 Android view 既有的問題。以 <code>CheckBox</code> 為例，你可以設定 <code>OnCheckedChangeListener</code> 來得知用戶改變剔選狀態。如果以 code 的形式改變 <code>CheckBox</code> 的狀態可以用 <code>setChecked</code> 這個 method。但 call 完 <code>setChecked</code> 後之前設定好的 <code>OnCheckedChangeListener</code> 都會收到 callback，變相很難分辨究竟那個 <code>onCheckedChanged</code> callback 是由用戶輸入行為觸發還是由 code call 了 setter 觸發。在 StackOverflow 有人提議可以改用 <code>OnClickListener</code> 取代 <code>OnCheckedChangeListener</code>，這樣就肯定 callback 是因為用戶輸入而觸發。另一個做法是在 call setter 前先把 <code>CheckBox</code> 的 <code>OnCheckedChangeListener</code> 設定 <code>null</code>，當 call 完 setter 後就把 <code>OnCheckedChangeListener</code> 還原。第一個做法不合乎語義，第二個做法又太古怪。但我們用 two-way data binding 好像不用理這個問題？不是，只是基本的 view 例如 <code>TextEdit</code> 和 <code>CheckBox</code> data binding 本身已附送 binding adapter，它背後的實作已經有處理這個問題。而 two-way data binding 的文檔都有特別提及這種 <a href=https://developer.android.com/topic/libraries/data-binding/two-way#infinite-loops>setter 和 listener 之間做成的無限循環問題</a>。它的解決方法是在 binding adapter call setter 前檢查當前 view 的值是不是和要設定的值一樣，如果一樣就不要再 call setter，以免觸發 listener 導致 data binding 發覺 view 的值有改變之後把背後的 <code>MutableLiveData</code> 或 <code>MutableStateFlow</code> 值改成 view 的值，因而再 call 多次 view 的 setter。</p><h2 id=recyclerview-局部更新><code>RecyclerView</code> 局部更新<a hidden class=anchor aria-hidden=true href=#recyclerview-局部更新>#</a></h2><p>之前示範了用 <code>DiffUtil.ItemCallback</code> 做自動計算新舊內容比對然後更新 <code>RecyclerView</code> 的 list item。但有時把 list item 的所有 view 都做一次 bind 的話可能會導致出現的效果。以 Instagram 的 news feed 為例，如果要更新 like 數的話，像我們之前的寫法會在資料變動後把整個 list item 重新 bind 過，導致影片重新載入。但我們期望看到的是影片是繼續播放不中斷而 like 的數字轉了。要做到這樣的效果我們可以 override <code>DiffUtil.ItemCallback</code> 的 <code>getChangePayload</code>。這個 method 會在 <code>areItemsTheSame</code> return <code>true</code> 並且 <code>areContentsTheSame</code> return <code>false</code> 時執行。<code>getChangePayload</code> 預設是 return <code>null</code>，你需要在 method 內找出兩個 object 之間的差異，然後把結果 return。它其實沒有限定 return type，你可以 return 一個 <code>Set</code> 內裏有表示不同 property 的 enum 表示改動過的 property。亦有其他人用 <code>Bundle</code> 來放兩個 object 之間的差異。</p><p>改完 <code>DiffUtil.ItemCallback</code> 後就要更改 <code>ListAdapter</code>。之前我們都是 override <code>onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int)</code>。但我們現在 override 了 <code>getChangePayload</code> 後就要在 adapter override <code>onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int, payloads: MutableList&lt;Any>)</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>onBindViewHolder</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>holder</span><span class=p>:</span> <span class=n>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>position</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>payloads</span><span class=p>:</span> <span class=n>MutableList</span><span class=p>&lt;</span><span class=n>Any</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>payloads</span><span class=p>.</span><span class=n>isEmpty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 完全不同，用回普通的 onBindViewHolder 做 bind
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>super</span><span class=p>.</span><span class=n>onBindViewHolder</span><span class=p>(</span><span class=n>holder</span><span class=p>,</span> <span class=n>position</span><span class=p>,</span> <span class=n>payloads</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// payload 第一個元素會有 getChangePayload return 出來的 object
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>diff</span> <span class=p>=</span> <span class=p>(</span><span class=n>payloads</span><span class=p>.</span><span class=n>first</span><span class=p>()</span> <span class=k>as</span><span class=p>?</span> <span class=n>Set</span><span class=p>&lt;</span><span class=n>DisplayContent</span><span class=p>&gt;).</span><span class=n>orEmpty</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>item</span> <span class=p>=</span> <span class=n>getItem</span><span class=p>(</span><span class=n>position</span><span class=p>)</span> <span class=o>?:</span> <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 之前已經 bind 過，按照 diff 有的 property 去 call 對應的 view setter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>做了局部更新後，我們應該要把 list item 由 data binding 轉為 view binding。因為用 data binding 又再直接從 code call view setter 覆寫 data binding 做的東西會很怪。</p><h2 id=由-data-binding-到-unidirectional-data-flow-再到-compose>由 data binding 到 unidirectional data flow 再到 Compose<a hidden class=anchor aria-hidden=true href=#由-data-binding-到-unidirectional-data-flow-再到-compose>#</a></h2><p>當習慣用 <code>LiveData</code> 和 <code>StateFlow</code> 後很自然地會把整頁的狀態以 <code>LiveData</code> 和 <code>Flow</code> 的形式放到 <code>ViewModel</code> 內。之後就是在 <code>ViewModel</code> 外露一些 method 回應用戶輸入。例如當用戶按下按鈕時會觸發 <code>ViewModel</code> 的一個 method。然後這個 method 會做一些東西（例如 call 了 backend 並等待 response）並且改變被 data binding 觀察的 <code>LiveData</code> 和 <code>StateFlow</code> 的值從而改變 UI。我們的示範 app 就是用這種作法，這樣就做到 unidirectional data flow 的效果。UI 只需要按照最新的狀態來顯示就可以了。但問題是 Android 傳統的 view 本身的設計就不是讓人這樣做的。如果是 <code>TextView</code> 你不斷 call <code>setText("hello")</code> 從用戶肉眼看起來就只是一個「hello」而已，沒有閃動之類的事發生。但到了 <code>EditText</code> call setter 那時如果本身輸入法有拼寫檢查的候選字的話 call 了 <code>setText</code> 就會清空輸入法候選字。所以如果刻意令 <code>EditText</code> 的狀態和 <code>ViewModel</code> 完全同步（callback 一收到改動就要 call <code>EditText.setText</code> 來統一兩邊狀態）的話用戶就感覺到有異樣。再到極端例子 <code>WebView</code>，它並沒有外露完整的 getter 和 setter 讓你能完全掌控 <code>WebView</code> 內部狀態。如果要保留和還原狀態就只能用 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code>，但那個 <code>Bundle</code> 不是讓你去讀而是讓 <code>WebView</code> 自己之後讀的。這種設計很容易會因為 <code>ViewModel</code> 的狀態跟 view 的狀態不完全同步而造成 bug。有些用 Android 傳統 view 做 unidirectional data flow 的示範 project 沒有特別做這類的示範（可能和我們的示範 app 一樣沒有用戶輸入的部分），讓人誤以為 unidirectional data flow 是容易做到，但到了實作時就發現問題多多。像以前那些 MVP 例子也是，很多都沒有考慮到 configuration change 的問題，只要一旋轉裝置之前的狀態就會消失。當然現在有 Architecture Component 和 <code>SavedStateHandle</code> 情況好了不少。但我想講的是傳統的 Android view 是很難完全做到所有狀態都交到 <code>ViewModel</code> 保留和控制，除非轉用 Compose 來寫 UI。</p><p>Compose 就是聲明式的 UI，我們不能像以前可以 call view 的 getter 取得它的狀態。相反，大部分的 Compose UI 都是沒有自己的狀態，狀態都是由外部（即是 <code>ViewModel</code>）傳進來，自己保留的狀態都是一些 <code>ViewModel</code> 不太重視的東西（例如動畫相關的值）。</p><p>以前我們做下面這類的 Chip 界面很多時都是在 layout XML 開一個空白的 <code>ViewGroup</code> 然後用 code 建構每一個 <code>Chip</code> 再塞進去 <code>ViewGroup</code>。然後當這些 Chip 更新時就把整個 <code>ViewGroup</code> 的 child view 清除再重新建構一堆新的 <code>Chip</code> 再塞進去。</p><figure><img loading=lazy src=chip.png><figcaption>Material Design 的 Chip</figcaption></figure><p>圖片擷自 <a href=https://material.io/components/chips>Material Design 網站</a></p><p>這樣做就不用花時間比對新舊 data 之間的差異而且不用處理那些 view 可以重用的問題。我們的示範 app 就是用了 <code>RecyclerView</code> 和 <code>DiffUtil.ItemCallback</code> 來做這些東西。但上面的例子大家應該都不會用 <code>RecyclerView</code> 來做。其實清空 <code>ViewGroup</code> 再做一堆新 view 有點像 Compose 的用法，但 Compose 能夠自動幫我們做新舊對比，而且不限於 <code>RecyclerView</code> 這類 UI。還有是用 Compose 的話就不用做清空的動作，因為它的寫法是 <code>ViewModel</code> 提供當前該頁全部的狀態，不單止是因應剛才用戶按了某個 chip 而只提供那個 chip 的資料。在我們的示範 app 我們都是循這個方向去寫，如果要轉做 Compose 的話相信不會有大問題。</p><h2 id=instrumentation-test>Instrumentation test<a hidden class=anchor aria-hidden=true href=#instrumentation-test>#</a></h2><p>我們一直寫的測試都是在電腦上執行，而不是在 Android 裝置。我們亦用了 <a href=http://robolectric.org/>Robolectric</a> 來補足 Android SDK 獨家的 class。如果是要拿到 Android 上面執行（不論是實機還是模擬器）的測試是叫做 instrumentation test。一般可以再細分兩類：UI test 和非 UI test。UI test 應該很容易明白，就是跟 UI 有關的，例如檢查界面顯示的內容、轉頁之類是不是合符預期。而非 UI 但又要放在 Android 執行的測試的例子有即場建立 in-memory SQLite database 檢查 SQL statement、foreign key constraint 是否正確。這些東西如果靠 mock 是不能真正檢查到這些東西，就算寫到出來亦會像謄文般把實作的 code 在 test case 中抄一遍（因為太多東西要 mock）。</p><p>如果是 UI test 的話可以參考我之前參加「<a href=https://medium.com/gdg-taipei/android-best-practice-challenge-for-mvvm-x-recyclerview-acd9e9ad0dae>Android # Best practice Challenge for MVVM x RecyclerView</a>」而做的 <a href=https://github.com/ericksli/DiffUtilRV>GitHub repo</a>。UI test 基本上都是用 <a href=https://developer.android.com/training/testing/espresso>Espresso</a> 來控制 UI 及檢查 UI 的元素，它背後是用 <a href=http://hamcrest.org/>Hamcrest</a> 這套 assertion 框架，跟我們之前示範用的 <a href=https://strikt.io/>Strikt</a> 有點似。不過 Espresso 難在它報錯時只會提供一大串 view hierarchy 給你看，但你又看不明白。所以最好還是寫了一小點就執行來看看是不是沒有問題，這樣就容易除錯。</p><p>如果已經用 Compose 的話就不是用 Espresso，要用 <a href=https://developer.android.com/jetpack/compose/testing>Compose 專用的測試 artifact</a>。其實 Espresso 和 Compose 的 UI test 寫法都是大同小異，基本上都是靠標記一些記號（例如 view ID）然後在 view tree 找到那些元素，之後檢查它的 attribute 或者是做一些用戶跟 app 的互動（例如按下按鈕）。為 view 加上測試的記號是 UI test 常用手法，例如 <code>ImageView</code> 用載入圖片 library 載入圖片的話可以順帶幫它 <code>setTag</code> 標記圖片網址，然後在 UI test 核對圖片網址。就算是 Compose 都是叫人用 semantics property 來做 UI test。</p><h2 id=coroutine>Coroutine<a hidden class=anchor aria-hidden=true href=#coroutine>#</a></h2><p>我們在示範 app 已經用了 Coroutine 和 Flow。但其實我們一直都沒有主動切換 thread。除了 Ktor client 那部分之外剩下的東西（包括那些 mapper）都是在 UI thread 執行。Coroutine 的運作方式就是在一條 thread 內跑到調用 suspending function 的指令時切換到不同的 Coroutine 來營造出幾個 Coroutine 在同時執行的效果。我們之在做自動更新時用的是 Coroutine 提供的 <code>delay</code> 而不是 Java 的 <code>Thread.sleep</code> 是因為 <code>Thread.sleep</code> 真是會把執行 Coroutine 的 thread（即是 UI thread）卡死，但 <code>delay</code> 就是會切換執行另一個 Coroutine，直至時間到為止。亦因為 Coroutine 不會在 suspending function 內每一句 statement 之間幫我們檢查現在 Coroutine 是不是已被取消，所以 Kotlin 的文檔有提到如果是寫循環語句的話最好在每次迭代時都檢查一次 <a href=https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html><code>isActive</code></a> 以確保我們在 Coroutine 取消後就停止執行。</p><p>Ktor client 和 OkHttp client 已經為我們處理了 thread 的事宜，否則我們一進去班次頁就出現 <code>NetworkOnMainThreadException</code>。如果真的想把部分流程放在另一條 thread 執行的話，就要用到 <a href=https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html>coroutine dispatcher</a>。這跟 RxJava 的 <a href=https://www.baeldung.com/rxjava-schedulers>scheduler</a> 和 Java 的 thread pool 有點似。常用的 dispatcher 有：</p><ul><li><code>Dispatchers.Main</code> 在 main thread 上行（視乎你用了甚麼 Coroutine 的 artifact，Android 的話是 UI thread）</li><li><code>Dispatchers.Default</code> 按裝置 CPU 核心數量來決定開多少條 thread 的 thread pool，但最少會有兩條，適合用來執行偏向 CPU 運算的東西</li><li><code>Dispatchers.IO</code> 都是 thread pool，但是專為 I/O 處理而設。如果它的 thread pool 不夠 thread 用的話可以隨時開新的 thread，用完後會銷毀。其實背後都是跟 <code>Dispatchers.Default</code> 共用 thread pool，如果本身有東西在 <code>Dispatchers.Default</code> 執行中的話就不會把原先的東西切換 thread</li></ul><p>Dispatcher 的用法是用 <code>launch</code>、<code>withContext</code> 包住想切換 thread 的部分：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>example</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;這句在 call example() 的 dispatcher 執行&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>withContext</span><span class=p>(</span><span class=n>Dispatchers</span><span class=p>.</span><span class=n>Default</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;這句在 Dispatchers.Default 執行&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;現在回到原先的 dispatcher 執行&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果整個 function 都想在 Dispatchers.Default 執行可以這樣寫
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>example2</span><span class=p>()</span> <span class=p>=</span> <span class=n>withContext</span><span class=p>(</span><span class=n>Dispatchers</span><span class=p>.</span><span class=n>Default</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;這句在 Dispatchers.Default 執行&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果是 <code>Flow</code> 的話，亦可以用 <code>flowOn</code> operator 指明 dispatcher：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>myFlow</span><span class=p>:</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=k>it</span> <span class=p>*</span> <span class=m>2</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>flowOn</span><span class=p>(</span><span class=n>Dispatchers</span><span class=p>.</span><span class=n>Default</span><span class=p>)</span> <span class=c1>// 這句以上 (map, onEach) 是在 Dispatchers.Default 執行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>.</span><span class=n>filter</span> <span class=p>{</span> <span class=k>it</span> <span class=p>%</span> <span class=m>2</span> <span class=o>==</span> <span class=m>0</span> <span class=p>}</span> <span class=c1>// 這句還是在 collect 那邊所在的 context 執行
</span></span></span></code></pre></div><p>不過為了方使測試，我們會用 dependency injection 取得 dispatcher。以下是用來提供 <code>CoroutineDispatcher</code> 的 Dagger module：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Qualifier</span>
</span></span><span class=line><span class=cl><span class=nd>@MustBeDocumented</span>
</span></span><span class=line><span class=cl><span class=nd>@Retention</span><span class=p>(</span><span class=n>AnnotationRetention</span><span class=p>.</span><span class=n>RUNTIME</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>annotation</span> <span class=k>class</span> <span class=nc>IoDispatcher</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Qualifier</span>
</span></span><span class=line><span class=cl><span class=nd>@MustBeDocumented</span>
</span></span><span class=line><span class=cl><span class=nd>@Retention</span><span class=p>(</span><span class=n>AnnotationRetention</span><span class=p>.</span><span class=n>RUNTIME</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>annotation</span> <span class=k>class</span> <span class=nc>DefaultDispatcher</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Qualifier</span>
</span></span><span class=line><span class=cl><span class=nd>@MustBeDocumented</span>
</span></span><span class=line><span class=cl><span class=nd>@Retention</span><span class=p>(</span><span class=n>AnnotationRetention</span><span class=p>.</span><span class=n>RUNTIME</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>annotation</span> <span class=k>class</span> <span class=nc>MainDispatcher</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Module</span>
</span></span><span class=line><span class=cl><span class=nd>@InstallIn</span><span class=p>(</span><span class=n>SingletonComponent</span><span class=o>::</span><span class=k>class</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>object</span> <span class=nc>CoroutinesModule</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Provides</span>
</span></span><span class=line><span class=cl>    <span class=nd>@IoDispatcher</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>provideIoDispatcher</span><span class=p>():</span> <span class=n>CoroutineDispatcher</span> <span class=p>=</span> <span class=n>Dispatchers</span><span class=p>.</span><span class=n>IO</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Provides</span>
</span></span><span class=line><span class=cl>    <span class=nd>@DefaultDispatcher</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>provideDefaultDispatcher</span><span class=p>():</span> <span class=n>CoroutineDispatcher</span> <span class=p>=</span> <span class=n>Dispatchers</span><span class=p>.</span><span class=n>Default</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Provides</span>
</span></span><span class=line><span class=cl>    <span class=nd>@MainDispatcher</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>provideMainDispatcher</span><span class=p>():</span> <span class=n>CoroutineDispatcher</span> <span class=p>=</span> <span class=n>Dispatchers</span><span class=p>.</span><span class=n>Main</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以上的 code 可以在 <a href=https://github.com/ericksli/eta-demo/blob/main/app/src/main/java/net/swiftzer/etademo/common/CoroutinesModule.kt>GitHub repo</a> 找到。</p><p>習慣上我們會在實際需要開 thread 的地方指明 dispatcher，例如 <code>withContext(Dispatchers.IO) { ... }</code> 包住讀寫檔案的 code。因為在那個位置是最清楚自己需要用那個 dispatcher。如果把指明 dispatcher 的工作放到跟實際操作很遠的位置（例如 <code>Activity</code>）的話調用的時候就要額外花時間檢查那些 code 是不是要用其他 dispatcher 執行，在 Android Developers 的文檔亦建議 suspending function 應寫成能安全地在 main thread 上調用。</p><h2 id=參考>參考<a hidden class=anchor aria-hidden=true href=#參考>#</a></h2><ul><li><a href=https://elizarov.medium.com/blocking-threads-suspending-coroutines-d33e11bf4761>Blocking threads, suspending coroutines</a></li><li><a href=https://developer.android.com/kotlin/coroutines/coroutines-adv>Improve app performance with Kotlin coroutines</a></li><li><a href=https://developer.android.com/kotlin/coroutines/coroutines-best-practices>Best practices for coroutines in Android</a></li><li><a href=https://developer.android.com/kotlin/flow>Kotlin flows on Android</a></li><li><a href=https://kotlinlang.org/docs/cancellation-and-timeouts.html>Cancellation and timeouts</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://eric.swiftzer.net/tags/2021-ithome-%E9%90%B5%E4%BA%BA%E8%B3%BD/>2021 iThome 鐵人賽</a></li><li><a href=https://eric.swiftzer.net/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=https://eric.swiftzer.net/2021/10/2021-ithome-ironman-30-wrapping-up/><span class=title>« 上一篇</span><br><span>2021 iThome 鐵人賽 Day 30：Wrapping up</span></a>
<a class=next href=https://eric.swiftzer.net/2021/10/2021-ithome-ironman-28-eta-screen-testing-2/><span class=title>下一篇 »</span><br><span>2021 iThome 鐵人賽 Day 28：ETA screen testing (2)</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//efilm.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://eric.swiftzer.net/>EricLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>