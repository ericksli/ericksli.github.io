<!doctype html><html lang=zh-hant-hk dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>2021 iThome 鐵人賽 Day 19：Station list screen (1) | EricLog</title>
<meta name=keywords content="2021 iThome 鐵人賽,Android">
<meta name=description content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 19 篇，你可到 iThome 查看原文。 文章目錄 最近兩篇都是講 navigation component，入面為了示">
<meta name=author content>
<link rel=canonical href=https://ithelp.ithome.com.tw/articles/10277315>
<link href=/assets/css/stylesheet.min.d1fc837a267f77f6ede89d1a89c4880a90c381d9e6673ad4a76a3ad1900b65f9.css integrity="sha256-0fyDeiZ/d/bt6J0aicSICpDDgdnmZzrUp2o60ZALZfk=" rel="preload stylesheet" as=style>
<link rel=icon href=https://eric.swiftzer.net/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://eric.swiftzer.net/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://eric.swiftzer.net/favicon-32x32.png>
<link rel=apple-touch-icon href=https://eric.swiftzer.net/apple-touch-icon.png>
<link rel=mask-icon href=https://eric.swiftzer.net/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=preconnect href=https://fonts.gstatic.com>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@300&display=swap" rel=stylesheet>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-1268728-8','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="2021 iThome 鐵人賽 Day 19：Station list screen (1)">
<meta property="og:description" content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 19 篇，你可到 iThome 查看原文。 文章目錄 最近兩篇都是講 navigation component，入面為了示">
<meta property="og:type" content="article">
<meta property="og:url" content="https://eric.swiftzer.net/2021/10/2021-ithome-ironman-19-station-list-screen-1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-04T00:00:00+08:00">
<meta property="article:modified_time" content="2021-10-04T00:00:00+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="2021 iThome 鐵人賽 Day 19：Station list screen (1)">
<meta name=twitter:description content="本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 19 篇，你可到 iThome 查看原文。 文章目錄 最近兩篇都是講 navigation component，入面為了示">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://eric.swiftzer.net/posts/"},{"@type":"ListItem","position":2,"name":"2021 iThome 鐵人賽 Day 19：Station list screen (1)","item":"https://eric.swiftzer.net/2021/10/2021-ithome-ironman-19-station-list-screen-1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2021 iThome 鐵人賽 Day 19：Station list screen (1)","name":"2021 iThome 鐵人賽 Day 19：Station list screen (1)","description":"本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 19 篇，你可到 iThome 查看原文。 文章目錄 最近兩篇都是講 navigation component，入面為了示","keywords":["2021 iThome 鐵人賽","Android"],"articleBody":" 本篇文章是 2021 iThome 鐵人賽參賽題目「寫一個列車抵站時間 Android App」的第 19 篇，你可到 iThome 查看原文。\n文章目錄\n 最近兩篇都是講 navigation component，入面為了示範設定 navigation 我們已經預先準備了兩頁的 Fragment class 和 layout XML，這樣我們之後就不用再跳去設定 navigation 的東西。現在開始會開始正式實作 app 的界面部分。我們會由車站列表頁開始實作，現在看看完成品：\n  車站列表 UI   這頁基本上就是一個 RecyclerView，當用戶點擊路綫時就會展開其車站，再點擊車站就會開啟抵站時間頁面。如果想做到縮放車站名的話，最簡單的方法就是當路綫名是一種 view type、車站名是另一種 view type，只需要準備好一個 List 交予 ListAdapter 讓它幫我們 render 就可以了。而路綫名旁邊的三角形 icon 會隨着車站名是否展開來決定顯示那一款 icon。這個亦可以在那個 List 時順帶提供給 ListAdapter 知道就可以了。\nListAdapter 是 RecyclerView.Adapter 的 subclass，特色是它已經為我們準備了 AsyncListDiffer 計算更新列表時那些 list item 如何處理（例如更換現有項目、刪除項目還是中途插入一個新項目之類）和 submitList(List)（提交要顯示的 List）。我們只需要準備一個 DiffUtil.ItemCallback 和一些平時 RecyclerView.Adapter 都會做的東西（ViewHolder class、onCreateViewHolder 、getItemViewType、onBindViewHolder）就可以了，其餘那些 notifyDataSetChanged、在 RecyclerView.Adapter 準備一個 List field 來儲存現在顯示的內容之類我們都不用處理，因為 ListAdapter 已經幫我們做好了。\nDependency 由於我們開始實作 UI 的部分，lifecycle 和其他 UI 的 dependency 是不能缺的。\nimplementation \"com.google.android.material:material:$materialVersion\" implementation \"androidx.constraintlayout:constraintlayout:$constraintLayoutVersion\" implementation \"androidx.activity:activity-ktx:$activityKtxVersion\" implementation \"androidx.fragment:fragment-ktx:$fragmentKtxVersion\" implementation \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion\" implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycleVersion\" implementation \"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycleVersion\" implementation \"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycleVersion\" 列表內容 Data class 我們首先要寫的是表示列表內容的 data class。我們會用 sealed interface 包住兩個 data class：Group 是路綫名、Child 是車站名。路綫和車站我們仍會以 enum 表示，直到要顯示一刻才會轉做 String。 Group 的 isExpanded 就是用來表示那個路綫是否被展開，而 Child 要有 Line 和 Station 是因為當我們點擊車站名時，要提供這兩樣東西才能進入抵站時間頁。\nsealed interface StationListItem { data class Group( val line: Line, val isExpanded: Boolean, ) : StationListItem data class Child( val line: Line, val station: Station, ) : StationListItem } DiffUtil.ItemCallback 做好了 StationListItem 後，我們就可以做 DiffUtil.ItemCallback。這個 class 就是 ListAdapter 能夠不用我們 call notifyDataSetChanged、notifyItemChanged 之類的 method 都能做到那些動畫的原因。DiffUtil 背後是用了 Eugene W. Myers 的 difference algorithm 來計算兩條 List 之間的變動，代你 call 了那些 notifyItemChanged、notifyItemRangeRemoved method。效能會比直接 call notifyDataSetChanged 更佳。而 ListAdapter 用了 AsyncListDiffer，就是把 DiffUtil 計算的動作放去非 UI thread 上面執行來提升效能。\nDiffUtil.ItemCallback 的寫法非常簡單，一般只需要 override 兩個 method：areItemsTheSame 和 areContentsTheSame。前者是判斷兩個 object 的 ID 是否相同；後者是判斷兩個 object 是否完全相同。如果 areItemsTheSame return false，那 areContentsTheSame 就不會被執行。\nobject DiffCallback : DiffUtil.ItemCallbackStationListItem() { override fun areItemsTheSame(oldItem: StationListItem, newItem: StationListItem): Boolean = when { oldItem is Group \u0026\u0026 newItem is Group - oldItem.line == newItem.line oldItem is Child \u0026\u0026 newItem is Child - oldItem.line == newItem.line \u0026\u0026 oldItem.station == oldItem.station else - false } override fun areContentsTheSame( oldItem: StationListItem, newItem: StationListItem ): Boolean = when { oldItem is Group \u0026\u0026 newItem is Group - oldItem == newItem oldItem is Child \u0026\u0026 newItem is Child - oldItem == newItem else - false } } 我們用 object 而不是普通 class 的原因是因為它沒有 side effect。在 areItemsTheSame 中，由於 Child 本身沒有 ID 讓我們比較，所以只能以 line 和 station 作對比。\n至於 areContentsTheSame 因為我們本身 Group 和 Child 都是 data class，所以我們可以放心用 Kotlin compiler 生成的 equals 來做比較。\nItem type layout XML 首先是路綫 item type，這次我們會用 data binding，因為又有 onClick、顯示文字和切換三角形 icon。以下是 station_list_line_item.xml 的內容：\n  xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"   name=\"group\" type=\"net.swiftzer.etademo.presentation.stationlist.StationListItem.Group\" /  name=\"presenter\" type=\"net.swiftzer.etademo.presentation.stationlist.LineStationPresenter\" /  name=\"callback\" type=\"net.swiftzer.etademo.presentation.stationlist.StationListAdapter.Callback\" /   android:layout_width=\"match_parent\" android:layout_height=\"48dp\" android:background=\"?selectableItemBackground\" android:clickable=\"true\" android:focusable=\"true\" android:gravity=\"center_vertical\" android:onClick=\"@{() - callback.toggleExpanded(group.line)}\" android:paddingStart=\"16dp\" android:paddingEnd=\"16dp\"  android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:contentDescription=\"@null\" android:src=\"@{group.expanded ? @drawable/ic_baseline_arrow_drop_down_24 : @drawable/ic_baseline_arrow_end_24}\" tools:src=\"@drawable/ic_baseline_arrow_drop_down_24\" /  android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"16dp\" android:layout_weight=\"1\" android:ellipsize=\"end\" android:maxLines=\"1\" android:text=\"@{presenter.mapLine(group.line)}\" android:textAlignment=\"viewStart\" android:textAppearance=\"?textAppearanceBody1\" tools:text=\"@tools:sample/cities\" /     路綫 item type 預覽   由於是用了 data binding，所以 XML 檔的 root tag 是  而不是 。 就是用來放 Java imports 和 data binding 用到的 variable。三個 variable 分別是：\n group 就是路綫的 object presenter 這個跟 MVP 的 presenter 沒甚麼關係，只是放了從 enum 取得車站路綫名稱的 code，方便重用 callback 當按下路綫或車站時會 call 的 callback  接着我們看看 data binding 的特有寫法。第一個是  的 android:onClick。@{() - callback.toggleExpanded(group.line)} 其實是 android.view.View.OnClickListener 的實作，不過用 lambda 來寫。凡是 data binding 都要用 @{} 包住，入面就是寫 Java code（不是 Kotlin）。整句的意思是當 onClick 時就會執行我的 lambda，因為 OnClickListener 的 onClick 第一個參數是 View 但我們不會用到，所以直接寫 () 就可以了。而 lambda 的內容就是 call callback.toggleExpanded(group.line)，用來通知按了這條路綫。關於這個 callback 我們之後會介紹。\n另一個要看的位置是  的 android:src。@{group.expanded ? @drawable/ic_baseline_arrow_drop_down_24 : @drawable/ic_baseline_arrow_end_24} 其實就是 Java ternary operator （這個寫法反而 Kotlin 沒有，一定要寫成 if (...) ... else ....）。全句的意思是如果 group.expanded 是 true 就顯示 @drawable/ic_baseline_arrow_drop_down_24 否則就顯示 @drawable/ic_baseline_arrow_end_24。Data binding 可以用 @drawable 引用 drawable resource，其他 resource type 例如 @string 和 @plurals 都可以用同樣寫法。\n還有一個要看的位置是  的 android:text。這次我們只是顯示由 enum 取得的路綫名稱。由於我們會在好幾個地方用到這個轉換邏輯，所以把它放到另一個 class。而 presenter.mapLine 會 return String ，那就可以交予 MaterialTextView 顯示。\n另一個 layout XML 是車站名稱，檔案名稱是 station_list_station_item.xml。\n  xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"   name=\"child\" type=\"net.swiftzer.etademo.presentation.stationlist.StationListItem.Child\" /  name=\"presenter\" type=\"net.swiftzer.etademo.presentation.stationlist.LineStationPresenter\" /  name=\"callback\" type=\"net.swiftzer.etademo.presentation.stationlist.StationListAdapter.Callback\" /   android:layout_width=\"match_parent\" android:layout_height=\"48dp\" android:background=\"?selectableItemBackground\" android:clickable=\"true\" android:ellipsize=\"end\" android:focusable=\"true\" android:gravity=\"center_vertical|start\" android:maxLines=\"1\" android:onClick=\"@{() - callback.onClickLineAndStation(child.line, child.station)}\" android:paddingStart=\"56dp\" android:paddingEnd=\"16dp\" android:text=\"@{presenter.mapStation(child.station)}\" android:textAlignment=\"viewStart\" android:textAppearance=\"?textAppearanceBody2\" tools:text=\"@tools:sample/cities\" /    車站 item type 預覽   這次我不解釋了，因為跟剛才那個大同小異。\nCallback 剛才 layout XML 看到的 callback 就是這樣子，沒甚麼特別：\ninterface Callback { fun toggleExpanded(line: Line) fun onClickLineAndStation(line: Line, station: Station) } Presenter 剛才在 layout XML 看到 LineStationPresenter 就是這樣子：\n@ActivityScoped class LineStationPresenter @Inject constructor(@ActivityContext context: Context) { private val language = context.resources.configuration.appLanguage fun mapLine(line: Line): String = when (language) { Language.CHINESE - line.zh Language.ENGLISH - line.en } fun mapStation(station: Station): String = when (language) { Language.CHINESE - station.zh Language.ENGLISH - station.en } } val Configuration.appLanguage: Language get() = if (ConfigurationCompat.getLocales(this)[0].language == Locale.CHINESE.language) { Language.CHINESE } else { Language.ENGLISH } 目的就是拿 Activity 的 Context 來得知現在的 Locale 然後決定輸出中文還是英文的路綫車站名。@ActivityScoped 是 Dagger Hilt 的 annotation，意思是這個 object 是跟隨 ActivityComponent 的生死。而 @ActivityContext 是 Dagger Hilt 提供的 qualifier，意思是我們要拿到 Acitivity 的 Context 而不是 Application 的 Context。我們不造新的 binding adapter 來做轉換是因為 binding adapter 是整個 app 都能用到，沒有 namespace。如果做的轉換只是個別 feature 才會用到的話我覺得不用 binding adapter 比較好。\n留意凡是 resource 的東西都不應放在 ViewModel 內轉換，這是因為界面語言是可以隨時轉換，如果用 Application 的 Context 來決定顯示甚麼語言會出現不一致。layout XML 用到的 string resource 就按最新語言設定顯示，因為跟隨 configuration change 重新建立 Activity 而重新 inflate layout XML；但如果從 ViewModel 的 constructor 取得 Application Context 的話，因為 ViewModel 能在 configuration change 後存活，那就是用 configuration change 之前的 Context 導致顯示的文字不是按照最新語言設定。\n如果不喜歡另外準備一個自訂的 class 放那些 enum 轉換文字的 code 的話，可以考慮使用 data binding 的 converter 功能。\nViewHolder 由於控制各 UI widget 顯示甚麼東西都交予 layout XML 用 data binding 控制，所以 ViewHolder 的角式就變了設置 data binding 和交資料給 data binding。現附上兩個 ViewHolder 的 code：\nclass LineItemViewHolder( private val binding: StationListLineItemBinding, lifecycleOwner: LifecycleOwner, presenter: LineStationPresenter, callback: Callback, ) : RecyclerView.ViewHolder(binding.root) { init { binding.lifecycleOwner = lifecycleOwner binding.presenter = presenter binding.callback = callback } fun bind(group: StationListItem.Group) { binding.group = group } } class StationItemViewHolder( private val binding: StationListStationItemBinding, lifecycleOwner: LifecycleOwner, presenter: LineStationPresenter, callback: Callback, ) : RecyclerView.ViewHolder(binding.root) { init { binding.lifecycleOwner = lifecycleOwner binding.presenter = presenter binding.callback = callback } fun bind(child: StationListItem.Child) { binding.child = child } } 或許你有看過一些教學或其他人會在改變 binding variable 後要 call binding.executePendingBindings() 觸發 UI 更新，但我們卻沒有這樣做。這是因為我們交了 LifecycleOwner 給 binding。如果我們交的 variable 是 LiveData 或 StateFlow，只要預先設定好 LifecycleOwner 就能自動觸發 UI 更新。這就是我們刻意在 ViewHolder 的 constructor 要求 LifecycleOwner 的原因。而 constructor 的 binding.root 就是從 binding object 取得 root view 的寫法（因為 RecyclerView.ViewHolder 的 constructor 需要 root view）。至於 bind method 就是讓 ListAdapter#onBindViewHolder 能夠提交當前 list item object 到 ViewHolder。\nAdapter 之前準備了這麼多的東西就是為了寫本篇最主要的 class：StationListAdapter。首是是它的基本骨架：\nclass StationListAdapter( lifecycleOwner: LifecycleOwner, presenter: LineStationPresenter, callback: Callback, ) : ListAdapterStationListItem, RecyclerView.ViewHolder(StationListItem.DiffCallback) { private val lifecycleOwner = WeakReference(lifecycleOwner) private val presenter = WeakReference(presenter) private val callback = WeakReference(callback) override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { TODO() } override fun getItemViewType(position: Int): Int = when (getItem(position)) { TODO() } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { TODO() } } 由於 ViewHolder 用了 LifecycleOwner、LineStationPresenter、Callback，所以我們在 StationListAdapter 的 constructor 傳入這些東西，好讓我們在 onCreateViewHolder 時能夠把它們傳入去 ViewHolder。而我們另外造了三個 WeakReference 把 constructor 帶進來的東西放入去是避免 memory leak。而 ListAdapter 的兩個 type argument 分別是 list item 和 ViewHolder 的 type。由於我們有兩個 ViewHolder，所以我們惟有選用 RecyclerView.ViewHolder。如果你的 ListAdapter 只有單一 ViewHolder，那可以直接用那個 ViewHolder type，這樣就能在 onBindViewHolder 直接用到那個 ViewHolder 而不用 type casting。當然你可以用 sealed class/interface 來避免強行 type casting。\n接着我們開始寫 getItemViewType，我們以 layout XML 的 R class 來做 view type ID，這樣就保證不會撞號碼。\noverride fun getItemViewType(position: Int): Int = when (getItem(position)) { is StationListItem.Group - R.layout.station_list_line_item is StationListItem.Child - R.layout.station_list_station_item else - throw UnsupportedOperationException(\"Unsupported view type at position $position\") } 然後是 onCreateViewHolder，我們會按照 view type 決定 instantiate 那一個 ViewHolder。\noverride fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val inflater = LayoutInflater.from(parent.context) return when (viewType) { R.layout.station_list_line_item - LineItemViewHolder( binding = StationListLineItemBinding.inflate(inflater, parent, false), lifecycleOwner = requireNotNull(lifecycleOwner.get()), presenter = requireNotNull(presenter.get()), callback = requireNotNull(callback.get()), ) R.layout.station_list_station_item - StationItemViewHolder( binding = StationListStationItemBinding.inflate(inflater, parent, false), lifecycleOwner = requireNotNull(lifecycleOwner.get()), presenter = requireNotNull(presenter.get()), callback = requireNotNull(callback.get()), ) else - throw UnsupportedOperationException(\"Unsupported view type $viewType\") } } 最後是 onBindViewHolder，由於我們用了 data binding，所以只需要提交那個 list item 進去 ViewHolder 就可以了。不過就算我們把 ViewHolder 用 sealed class/interface 包住都要替 list item 做 type casting，除非整個 list 只有一款 list item class。\noverride fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { when (val item = getItem(position)) { is StationListItem.Group - (holder as LineItemViewHolder).bind(item) is StationListItem.Child - (holder as StationItemViewHolder).bind(item) } } 現在 StationListAdapter 已經完成了，完整的 code 可以到 GitHub repo 查閱。下一篇會實作 ViewModel、Fragment 的部分，屆時就能完成車站列表頁的部分。\n","wordCount":"3786","inLanguage":"en","datePublished":"2021-10-04T00:00:00+08:00","dateModified":"2021-10-04T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://eric.swiftzer.net/2021/10/2021-ithome-ironman-19-station-list-screen-1/"},"publisher":{"@type":"Organization","name":"EricLog","logo":{"@type":"ImageObject","url":"https://eric.swiftzer.net/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://eric.swiftzer.net/ accesskey=h title="EricLog (Alt + H)">EricLog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://eric.swiftzer.net/fonts/ title=Fonts>
<span>Fonts</span>
</a>
</li>
<li>
<a href=https://eric.swiftzer.net/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://eric.swiftzer.net/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://eric.swiftzer.net/about/ title=About>
<span>About</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs>
<a href=https://eric.swiftzer.net/>Home</a>&nbsp;»&nbsp;<a href=https://eric.swiftzer.net/posts/>Posts</a>
</div>
<h1 class=post-title>
2021 iThome 鐵人賽 Day 19：Station list screen (1)
</h1>
<div class=post-meta>October 4, 2021
</div>
</header>
<div class=post-content>
<blockquote>
<p>本篇文章是 <a href=https://ithelp.ithome.com.tw/2021ironman>2021 iThome 鐵人賽</a>參賽題目「<a href=https://ithelp.ithome.com.tw/users/20139666/ironman/4661>寫一個列車抵站時間 Android App</a>」的第 19 篇，你可到 iThome <a href=https://ithelp.ithome.com.tw/articles/10277315>查看原文</a>。</p>
<p><a href=https://eric.swiftzer.net/2021-ithome-ironman/>文章目錄</a></p>
</blockquote>
<p>最近兩篇都是講 navigation component，入面為了示範設定 navigation 我們已經預先準備了兩頁的 <code>Fragment</code> class 和 layout XML，這樣我們之後就不用再跳去設定 navigation 的東西。現在開始會開始正式實作 app 的界面部分。我們會由車站列表頁開始實作，現在看看完成品：</p>
<figure>
<img loading=lazy src=station-list-ui.png> <figcaption>
車站列表 UI
</figcaption>
</figure>
<p>這頁基本上就是一個 <code>RecyclerView</code>，當用戶點擊路綫時就會展開其車站，再點擊車站就會開啟抵站時間頁面。如果想做到縮放車站名的話，最簡單的方法就是當路綫名是一種 view type、車站名是另一種 view type，只需要準備好一個 <code>List</code> 交予 <a href=https://developer.android.com/reference/androidx/recyclerview/widget/ListAdapter><code>ListAdapter</code></a> 讓它幫我們 render 就可以了。而路綫名旁邊的三角形 icon 會隨着車站名是否展開來決定顯示那一款 icon。這個亦可以在那個 <code>List</code> 時順帶提供給 <code>ListAdapter</code> 知道就可以了。</p>
<p><code>ListAdapter</code> 是 <code>RecyclerView.Adapter</code> 的 subclass，特色是它已經為我們準備了 <code>AsyncListDiffer</code> 計算更新列表時那些 list item 如何處理（例如更換現有項目、刪除項目還是中途插入一個新項目之類）和 <code>submitList(List)</code>（提交要顯示的 <code>List</code>）。我們只需要準備一個 <code>DiffUtil.ItemCallback</code> 和一些平時 <code>RecyclerView.Adapter</code> 都會做的東西（<code>ViewHolder</code> class、<code>onCreateViewHolder</code> 、<code>getItemViewType</code>、<code>onBindViewHolder</code>）就可以了，其餘那些 <code>notifyDataSetChanged</code>、在 <code>RecyclerView.Adapter</code> 準備一個 <code>List</code> field 來儲存現在顯示的內容之類我們都不用處理，因為 <code>ListAdapter</code> 已經幫我們做好了。</p>
<h2 id=dependency>Dependency<a hidden class=anchor aria-hidden=true href=#dependency>#</a></h2>
<p>由於我們開始實作 UI 的部分，lifecycle 和其他 UI 的 dependency 是不能缺的。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-groovy data-lang=groovy><span class=n>implementation</span> <span class=s2>&#34;com.google.android.material:material:$materialVersion&#34;</span>
<span class=n>implementation</span> <span class=s2>&#34;androidx.constraintlayout:constraintlayout:$constraintLayoutVersion&#34;</span>
<span class=n>implementation</span> <span class=s2>&#34;androidx.activity:activity-ktx:$activityKtxVersion&#34;</span>
<span class=n>implementation</span> <span class=s2>&#34;androidx.fragment:fragment-ktx:$fragmentKtxVersion&#34;</span>
<span class=n>implementation</span> <span class=s2>&#34;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion&#34;</span>
<span class=n>implementation</span> <span class=s2>&#34;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycleVersion&#34;</span>
<span class=n>implementation</span> <span class=s2>&#34;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycleVersion&#34;</span>
<span class=n>implementation</span> <span class=s2>&#34;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycleVersion&#34;</span>
</code></pre></div><h2 id=列表內容-data-class>列表內容 Data class<a hidden class=anchor aria-hidden=true href=#列表內容-data-class>#</a></h2>
<p>我們首先要寫的是表示列表內容的 data class。我們會用 sealed interface 包住兩個 data class：<code>Group</code> 是路綫名、<code>Child</code> 是車站名。路綫和車站我們仍會以 enum 表示，直到要顯示一刻才會轉做 <code>String</code>。 <code>Group</code> 的 <code>isExpanded</code> 就是用來表示那個路綫是否被展開，而 <code>Child</code> 要有 <code>Line</code> 和 <code>Station</code> 是因為當我們點擊車站名時，要提供這兩樣東西才能進入抵站時間頁。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>sealed</span> <span class=k>interface</span> <span class=nc>StationListItem</span> <span class=p>{</span>
    <span class=k>data</span> <span class=k>class</span> <span class=nc>Group</span><span class=p>(</span>
        <span class=k>val</span> <span class=py>line</span><span class=p>:</span> <span class=n>Line</span><span class=p>,</span>
        <span class=k>val</span> <span class=py>isExpanded</span><span class=p>:</span> <span class=n>Boolean</span><span class=p>,</span>
    <span class=p>)</span> <span class=p>:</span> <span class=n>StationListItem</span>

    <span class=k>data</span> <span class=k>class</span> <span class=nc>Child</span><span class=p>(</span>
        <span class=k>val</span> <span class=py>line</span><span class=p>:</span> <span class=n>Line</span><span class=p>,</span>
        <span class=k>val</span> <span class=py>station</span><span class=p>:</span> <span class=n>Station</span><span class=p>,</span>
    <span class=p>)</span> <span class=p>:</span> <span class=n>StationListItem</span>
<span class=p>}</span>
</code></pre></div><h2 id=diffutilitemcallback><code>DiffUtil.ItemCallback</code><a hidden class=anchor aria-hidden=true href=#diffutilitemcallback>#</a></h2>
<p>做好了 <code>StationListItem</code> 後，我們就可以做 <code>DiffUtil.ItemCallback</code>。這個 class 就是 <code>ListAdapter</code> 能夠不用我們 call <code>notifyDataSetChanged</code>、<code>notifyItemChanged</code> 之類的 method 都能做到那些動畫的原因。<code>DiffUtil</code> 背後是用了 Eugene W. Myers 的 difference algorithm 來計算兩條 <code>List</code> 之間的變動，代你 call 了那些 <code>notifyItemChanged</code>、<code>notifyItemRangeRemoved</code> method。效能會比直接 call <code>notifyDataSetChanged</code> 更佳。而 <code>ListAdapter</code> 用了 <code>AsyncListDiffer</code>，就是把 <code>DiffUtil</code> 計算的動作放去非 UI thread 上面執行來提升效能。</p>
<p><code>DiffUtil.ItemCallback</code> 的寫法非常簡單，一般只需要 override 兩個 method：<code>areItemsTheSame</code> 和 <code>areContentsTheSame</code>。前者是判斷兩個 object 的 ID 是否相同；後者是判斷兩個 object 是否完全相同。如果 <code>areItemsTheSame</code> return false，那 <code>areContentsTheSame</code> 就不會被執行。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>object</span> <span class=nc>DiffCallback</span> <span class=p>:</span> <span class=n>DiffUtil</span><span class=p>.</span><span class=n>ItemCallback</span><span class=p>&lt;</span><span class=n>StationListItem</span><span class=p>&gt;()</span> <span class=p>{</span>
    <span class=k>override</span> <span class=k>fun</span> <span class=nf>areItemsTheSame</span><span class=p>(</span><span class=n>oldItem</span><span class=p>:</span> <span class=n>StationListItem</span><span class=p>,</span> <span class=n>newItem</span><span class=p>:</span> <span class=n>StationListItem</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>=</span>
        <span class=k>when</span> <span class=p>{</span>
            <span class=n>oldItem</span> <span class=k>is</span> <span class=n>Group</span> <span class=o>&amp;&amp;</span> <span class=n>newItem</span> <span class=k>is</span> <span class=n>Group</span> <span class=o>-&gt;</span> <span class=n>oldItem</span><span class=p>.</span><span class=n>line</span> <span class=o>==</span> <span class=n>newItem</span><span class=p>.</span><span class=n>line</span>
            <span class=n>oldItem</span> <span class=k>is</span> <span class=n>Child</span> <span class=o>&amp;&amp;</span> <span class=n>newItem</span> <span class=k>is</span> <span class=n>Child</span> <span class=o>-&gt;</span> <span class=n>oldItem</span><span class=p>.</span><span class=n>line</span> <span class=o>==</span> <span class=n>newItem</span><span class=p>.</span><span class=n>line</span> <span class=o>&amp;&amp;</span> <span class=n>oldItem</span><span class=p>.</span><span class=n>station</span> <span class=o>==</span> <span class=n>oldItem</span><span class=p>.</span><span class=n>station</span>
            <span class=k>else</span> <span class=o>-&gt;</span> <span class=k>false</span>
        <span class=p>}</span>

    <span class=k>override</span> <span class=k>fun</span> <span class=nf>areContentsTheSame</span><span class=p>(</span>
        <span class=n>oldItem</span><span class=p>:</span> <span class=n>StationListItem</span><span class=p>,</span>
        <span class=n>newItem</span><span class=p>:</span> <span class=n>StationListItem</span>
    <span class=p>):</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=k>when</span> <span class=p>{</span>
        <span class=n>oldItem</span> <span class=k>is</span> <span class=n>Group</span> <span class=o>&amp;&amp;</span> <span class=n>newItem</span> <span class=k>is</span> <span class=n>Group</span> <span class=o>-&gt;</span> <span class=n>oldItem</span> <span class=o>==</span> <span class=n>newItem</span>
        <span class=n>oldItem</span> <span class=k>is</span> <span class=n>Child</span> <span class=o>&amp;&amp;</span> <span class=n>newItem</span> <span class=k>is</span> <span class=n>Child</span> <span class=o>-&gt;</span> <span class=n>oldItem</span> <span class=o>==</span> <span class=n>newItem</span>
        <span class=k>else</span> <span class=o>-&gt;</span> <span class=k>false</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>我們用 <code>object</code> 而不是普通 <code>class</code> 的原因是因為它沒有 side effect。在 <code>areItemsTheSame</code> 中，由於 <code>Child</code> 本身沒有 ID 讓我們比較，所以只能以 <code>line</code> 和 <code>station</code> 作對比。</p>
<p>至於 <code>areContentsTheSame</code> 因為我們本身 <code>Group</code> 和 <code>Child</code> 都是 data class，所以我們可以放心用 Kotlin compiler 生成的 <code>equals</code> 來做比較。</p>
<h2 id=item-type-layout-xml>Item type layout XML<a hidden class=anchor aria-hidden=true href=#item-type-layout-xml>#</a></h2>
<p>首先是路綫 item type，這次我們會用 data binding，因為又有 <code>onClick</code>、顯示文字和切換三角形 icon。以下是 <em>station_list_line_item.xml</em> 的內容：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=cp>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
<span class=nt>&lt;layout</span> <span class=na>xmlns:android=</span><span class=s>&#34;http://schemas.android.com/apk/res/android&#34;</span>
    <span class=na>xmlns:tools=</span><span class=s>&#34;http://schemas.android.com/tools&#34;</span><span class=nt>&gt;</span>

    <span class=nt>&lt;data&gt;</span>

        <span class=nt>&lt;variable</span>
            <span class=na>name=</span><span class=s>&#34;group&#34;</span>
            <span class=na>type=</span><span class=s>&#34;net.swiftzer.etademo.presentation.stationlist.StationListItem.Group&#34;</span> <span class=nt>/&gt;</span>

        <span class=nt>&lt;variable</span>
            <span class=na>name=</span><span class=s>&#34;presenter&#34;</span>
            <span class=na>type=</span><span class=s>&#34;net.swiftzer.etademo.presentation.stationlist.LineStationPresenter&#34;</span> <span class=nt>/&gt;</span>

        <span class=nt>&lt;variable</span>
            <span class=na>name=</span><span class=s>&#34;callback&#34;</span>
            <span class=na>type=</span><span class=s>&#34;net.swiftzer.etademo.presentation.stationlist.StationListAdapter.Callback&#34;</span> <span class=nt>/&gt;</span>
    <span class=nt>&lt;/data&gt;</span>

    <span class=nt>&lt;LinearLayout</span>
        <span class=na>android:layout_width=</span><span class=s>&#34;match_parent&#34;</span>
        <span class=na>android:layout_height=</span><span class=s>&#34;48dp&#34;</span>
        <span class=na>android:background=</span><span class=s>&#34;?selectableItemBackground&#34;</span>
        <span class=na>android:clickable=</span><span class=s>&#34;true&#34;</span>
        <span class=na>android:focusable=</span><span class=s>&#34;true&#34;</span>
        <span class=na>android:gravity=</span><span class=s>&#34;center_vertical&#34;</span>
        <span class=na>android:onClick=</span><span class=s>&#34;@{() -&gt; callback.toggleExpanded(group.line)}&#34;</span>
        <span class=na>android:paddingStart=</span><span class=s>&#34;16dp&#34;</span>
        <span class=na>android:paddingEnd=</span><span class=s>&#34;16dp&#34;</span><span class=nt>&gt;</span>

        <span class=nt>&lt;ImageView</span>
            <span class=na>android:layout_width=</span><span class=s>&#34;wrap_content&#34;</span>
            <span class=na>android:layout_height=</span><span class=s>&#34;wrap_content&#34;</span>
            <span class=na>android:contentDescription=</span><span class=s>&#34;@null&#34;</span>
            <span class=na>android:src=</span><span class=s>&#34;@{group.expanded ? @drawable/ic_baseline_arrow_drop_down_24 : @drawable/ic_baseline_arrow_end_24}&#34;</span>
            <span class=na>tools:src=</span><span class=s>&#34;@drawable/ic_baseline_arrow_drop_down_24&#34;</span> <span class=nt>/&gt;</span>

        <span class=nt>&lt;com.google.android.material.textview.MaterialTextView</span>
            <span class=na>android:layout_width=</span><span class=s>&#34;0dp&#34;</span>
            <span class=na>android:layout_height=</span><span class=s>&#34;wrap_content&#34;</span>
            <span class=na>android:layout_marginStart=</span><span class=s>&#34;16dp&#34;</span>
            <span class=na>android:layout_weight=</span><span class=s>&#34;1&#34;</span>
            <span class=na>android:ellipsize=</span><span class=s>&#34;end&#34;</span>
            <span class=na>android:maxLines=</span><span class=s>&#34;1&#34;</span>
            <span class=na>android:text=</span><span class=s>&#34;@{presenter.mapLine(group.line)}&#34;</span>
            <span class=na>android:textAlignment=</span><span class=s>&#34;viewStart&#34;</span>
            <span class=na>android:textAppearance=</span><span class=s>&#34;?textAppearanceBody1&#34;</span>
            <span class=na>tools:text=</span><span class=s>&#34;@tools:sample/cities&#34;</span> <span class=nt>/&gt;</span>
    <span class=nt>&lt;/LinearLayout&gt;</span>
<span class=nt>&lt;/layout&gt;</span>
</code></pre></div><figure>
<img loading=lazy src=parent.png> <figcaption>
路綫 item type 預覽
</figcaption>
</figure>
<p>由於是用了 data binding，所以 XML 檔的 root tag 是 <code>&lt;layout></code> 而不是 <code>&lt;LinearLayout></code>。<code>&lt;data></code> 就是用來放 Java imports 和 data binding 用到的 variable。三個 variable 分別是：</p>
<ol>
<li><code>group</code> 就是路綫的 object</li>
<li><code>presenter</code> 這個跟 MVP 的 presenter 沒甚麼關係，只是放了從 enum 取得車站路綫名稱的 code，方便重用</li>
<li><code>callback</code> 當按下路綫或車站時會 call 的 callback</li>
</ol>
<p>接着我們看看 data binding 的特有寫法。第一個是 <code>&lt;LinearLayout></code> 的 <code>android:onClick</code>。<code>@{() -> callback.toggleExpanded(group.line)}</code> 其實是 <code>android.view.View.OnClickListener</code> 的實作，不過用 lambda 來寫。凡是 data binding 都要用 <code>@{}</code> 包住，入面就是寫 Java code（不是 Kotlin）。整句的意思是當 <code>onClick</code> 時就會執行我的 lambda，因為 <code>OnClickListener</code> 的 <code>onClick</code> 第一個參數是 <code>View</code> 但我們不會用到，所以直接寫 <code>()</code> 就可以了。而 lambda 的內容就是 call <code>callback.toggleExpanded(group.line)</code>，用來通知按了這條路綫。關於這個 callback 我們之後會介紹。</p>
<p>另一個要看的位置是 <code>&lt;ImageView></code> 的 <code>android:src</code>。<code>@{group.expanded ? @drawable/ic_baseline_arrow_drop_down_24 : @drawable/ic_baseline_arrow_end_24}</code> 其實就是 <a href=https://www.baeldung.com/java-ternary-operator>Java ternary operator</a> （這個寫法反而 Kotlin 沒有，一定要寫成 <code>if (...) ... else ....</code>）。全句的意思是如果 <code>group.expanded</code> 是 <code>true</code> 就顯示 <code>@drawable/ic_baseline_arrow_drop_down_24</code> 否則就顯示 <code>@drawable/ic_baseline_arrow_end_24</code>。Data binding 可以用 <code>@drawable</code> 引用 drawable resource，其他 resource type 例如 <code>@string</code> 和 <code>@plurals</code> 都可以用同樣寫法。</p>
<p>還有一個要看的位置是 <code>&lt;MaterialTextView></code> 的 <code>android:text</code>。這次我們只是顯示由 enum 取得的路綫名稱。由於我們會在好幾個地方用到這個轉換邏輯，所以把它放到另一個 class。而 <code>presenter.mapLine</code> 會 return <code>String</code> ，那就可以交予 <code>MaterialTextView</code> 顯示。</p>
<p>另一個 layout XML 是車站名稱，檔案名稱是 <em>station_list_station_item.xml</em>。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=cp>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
<span class=nt>&lt;layout</span> <span class=na>xmlns:android=</span><span class=s>&#34;http://schemas.android.com/apk/res/android&#34;</span>
    <span class=na>xmlns:tools=</span><span class=s>&#34;http://schemas.android.com/tools&#34;</span><span class=nt>&gt;</span>

    <span class=nt>&lt;data&gt;</span>

        <span class=nt>&lt;variable</span>
            <span class=na>name=</span><span class=s>&#34;child&#34;</span>
            <span class=na>type=</span><span class=s>&#34;net.swiftzer.etademo.presentation.stationlist.StationListItem.Child&#34;</span> <span class=nt>/&gt;</span>

        <span class=nt>&lt;variable</span>
            <span class=na>name=</span><span class=s>&#34;presenter&#34;</span>
            <span class=na>type=</span><span class=s>&#34;net.swiftzer.etademo.presentation.stationlist.LineStationPresenter&#34;</span> <span class=nt>/&gt;</span>

        <span class=nt>&lt;variable</span>
            <span class=na>name=</span><span class=s>&#34;callback&#34;</span>
            <span class=na>type=</span><span class=s>&#34;net.swiftzer.etademo.presentation.stationlist.StationListAdapter.Callback&#34;</span> <span class=nt>/&gt;</span>
    <span class=nt>&lt;/data&gt;</span>

    <span class=nt>&lt;com.google.android.material.textview.MaterialTextView</span>
        <span class=na>android:layout_width=</span><span class=s>&#34;match_parent&#34;</span>
        <span class=na>android:layout_height=</span><span class=s>&#34;48dp&#34;</span>
        <span class=na>android:background=</span><span class=s>&#34;?selectableItemBackground&#34;</span>
        <span class=na>android:clickable=</span><span class=s>&#34;true&#34;</span>
        <span class=na>android:ellipsize=</span><span class=s>&#34;end&#34;</span>
        <span class=na>android:focusable=</span><span class=s>&#34;true&#34;</span>
        <span class=na>android:gravity=</span><span class=s>&#34;center_vertical|start&#34;</span>
        <span class=na>android:maxLines=</span><span class=s>&#34;1&#34;</span>
        <span class=na>android:onClick=</span><span class=s>&#34;@{() -&gt; callback.onClickLineAndStation(child.line, child.station)}&#34;</span>
        <span class=na>android:paddingStart=</span><span class=s>&#34;56dp&#34;</span>
        <span class=na>android:paddingEnd=</span><span class=s>&#34;16dp&#34;</span>
        <span class=na>android:text=</span><span class=s>&#34;@{presenter.mapStation(child.station)}&#34;</span>
        <span class=na>android:textAlignment=</span><span class=s>&#34;viewStart&#34;</span>
        <span class=na>android:textAppearance=</span><span class=s>&#34;?textAppearanceBody2&#34;</span>
        <span class=na>tools:text=</span><span class=s>&#34;@tools:sample/cities&#34;</span> <span class=nt>/&gt;</span>
<span class=nt>&lt;/layout&gt;</span>
</code></pre></div><figure>
<img loading=lazy src=child.png> <figcaption>
車站 item type 預覽
</figcaption>
</figure>
<p>這次我不解釋了，因為跟剛才那個大同小異。</p>
<h2 id=callback>Callback<a hidden class=anchor aria-hidden=true href=#callback>#</a></h2>
<p>剛才 layout XML 看到的 callback 就是這樣子，沒甚麼特別：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>interface</span> <span class=nc>Callback</span> <span class=p>{</span>
    <span class=k>fun</span> <span class=nf>toggleExpanded</span><span class=p>(</span><span class=n>line</span><span class=p>:</span> <span class=n>Line</span><span class=p>)</span>
    <span class=k>fun</span> <span class=nf>onClickLineAndStation</span><span class=p>(</span><span class=n>line</span><span class=p>:</span> <span class=n>Line</span><span class=p>,</span> <span class=n>station</span><span class=p>:</span> <span class=n>Station</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><h2 id=presenter>Presenter<a hidden class=anchor aria-hidden=true href=#presenter>#</a></h2>
<p>剛才在 layout XML 看到 <code>LineStationPresenter</code> 就是這樣子：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=nd>@ActivityScoped</span>
<span class=k>class</span> <span class=nc>LineStationPresenter</span> <span class=nd>@Inject</span> <span class=k>constructor</span><span class=p>(</span><span class=nd>@ActivityContext</span> <span class=n>context</span><span class=p>:</span> <span class=n>Context</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>private</span> <span class=k>val</span> <span class=py>language</span> <span class=p>=</span> <span class=n>context</span><span class=p>.</span><span class=n>resources</span><span class=p>.</span><span class=n>configuration</span><span class=p>.</span><span class=n>appLanguage</span>

    <span class=k>fun</span> <span class=nf>mapLine</span><span class=p>(</span><span class=n>line</span><span class=p>:</span> <span class=n>Line</span><span class=p>):</span> <span class=n>String</span> <span class=p>=</span> <span class=k>when</span> <span class=p>(</span><span class=n>language</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Language</span><span class=p>.</span><span class=n>CHINESE</span> <span class=o>-&gt;</span> <span class=n>line</span><span class=p>.</span><span class=n>zh</span>
        <span class=n>Language</span><span class=p>.</span><span class=n>ENGLISH</span> <span class=o>-&gt;</span> <span class=n>line</span><span class=p>.</span><span class=n>en</span>
    <span class=p>}</span>

    <span class=k>fun</span> <span class=nf>mapStation</span><span class=p>(</span><span class=n>station</span><span class=p>:</span> <span class=n>Station</span><span class=p>):</span> <span class=n>String</span> <span class=p>=</span> <span class=k>when</span> <span class=p>(</span><span class=n>language</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Language</span><span class=p>.</span><span class=n>CHINESE</span> <span class=o>-&gt;</span> <span class=n>station</span><span class=p>.</span><span class=n>zh</span>
        <span class=n>Language</span><span class=p>.</span><span class=n>ENGLISH</span> <span class=o>-&gt;</span> <span class=n>station</span><span class=p>.</span><span class=n>en</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=k>val</span> <span class=py>Configuration</span><span class=p>.</span><span class=n>appLanguage</span><span class=p>:</span> <span class=n>Language</span>
    <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=k>if</span> <span class=p>(</span><span class=n>ConfigurationCompat</span><span class=p>.</span><span class=n>getLocales</span><span class=p>(</span><span class=k>this</span><span class=p>)[</span><span class=m>0</span><span class=p>].</span><span class=n>language</span> <span class=o>==</span> <span class=n>Locale</span><span class=p>.</span><span class=n>CHINESE</span><span class=p>.</span><span class=n>language</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Language</span><span class=p>.</span><span class=n>CHINESE</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>Language</span><span class=p>.</span><span class=n>ENGLISH</span>
    <span class=p>}</span>
</code></pre></div><p>目的就是拿 <code>Activity</code> 的 <code>Context</code> 來得知現在的 <code>Locale</code> 然後決定輸出中文還是英文的路綫車站名。<code>@ActivityScoped</code> 是 Dagger Hilt 的 annotation，意思是這個 object 是跟隨 <code>ActivityComponent</code> 的生死。而 <code>@ActivityContext</code> 是 Dagger Hilt 提供的 qualifier，意思是我們要拿到 <code>Acitivity</code> 的 <code>Context</code> 而不是 <code>Application</code> 的 <code>Context</code>。我們不造新的 binding adapter 來做轉換是因為 binding adapter 是整個 app 都能用到，沒有 namespace。如果做的轉換只是個別 feature 才會用到的話我覺得不用 binding adapter 比較好。</p>
<p>留意凡是 resource 的東西都不應放在 <code>ViewModel</code> 內轉換，這是因為界面語言是可以隨時轉換，如果用 <code>Application</code> 的 <code>Context</code> 來決定顯示甚麼語言會出現不一致。layout XML 用到的 string resource 就按最新語言設定顯示，因為跟隨 configuration change 重新建立 <code>Activity</code> 而重新 inflate layout XML；但如果從 <code>ViewModel</code> 的 constructor 取得 <code>Application</code> <code>Context</code> 的話，因為 <code>ViewModel</code> 能在 configuration change 後存活，那就是用 configuration change 之前的 <code>Context</code> 導致顯示的文字不是按照最新語言設定。</p>
<p>如果不喜歡另外準備一個自訂的 class 放那些 enum 轉換文字的 code 的話，可以考慮使用 <a href=https://developer.android.com/topic/libraries/data-binding/two-way#converters>data binding 的 converter 功能</a>。</p>
<h2 id=viewholder><code>ViewHolder</code><a hidden class=anchor aria-hidden=true href=#viewholder>#</a></h2>
<p>由於控制各 UI widget 顯示甚麼東西都交予 layout XML 用 data binding 控制，所以 <code>ViewHolder</code> 的角式就變了設置 data binding 和交資料給 data binding。現附上兩個 <code>ViewHolder</code> 的 code：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>class</span> <span class=nc>LineItemViewHolder</span><span class=p>(</span>
    <span class=k>private</span> <span class=k>val</span> <span class=py>binding</span><span class=p>:</span> <span class=n>StationListLineItemBinding</span><span class=p>,</span>
    <span class=n>lifecycleOwner</span><span class=p>:</span> <span class=n>LifecycleOwner</span><span class=p>,</span>
    <span class=n>presenter</span><span class=p>:</span> <span class=n>LineStationPresenter</span><span class=p>,</span>
    <span class=n>callback</span><span class=p>:</span> <span class=n>Callback</span><span class=p>,</span>
<span class=p>)</span> <span class=p>:</span> <span class=n>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span><span class=p>(</span><span class=n>binding</span><span class=p>.</span><span class=n>root</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>init</span> <span class=p>{</span>
        <span class=n>binding</span><span class=p>.</span><span class=n>lifecycleOwner</span> <span class=p>=</span> <span class=n>lifecycleOwner</span>
        <span class=n>binding</span><span class=p>.</span><span class=n>presenter</span> <span class=p>=</span> <span class=n>presenter</span>
        <span class=n>binding</span><span class=p>.</span><span class=n>callback</span> <span class=p>=</span> <span class=n>callback</span>
    <span class=p>}</span>

    <span class=k>fun</span> <span class=nf>bind</span><span class=p>(</span><span class=n>group</span><span class=p>:</span> <span class=n>StationListItem</span><span class=p>.</span><span class=n>Group</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>binding</span><span class=p>.</span><span class=n>group</span> <span class=p>=</span> <span class=n>group</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>class</span> <span class=nc>StationItemViewHolder</span><span class=p>(</span>
    <span class=k>private</span> <span class=k>val</span> <span class=py>binding</span><span class=p>:</span> <span class=n>StationListStationItemBinding</span><span class=p>,</span>
    <span class=n>lifecycleOwner</span><span class=p>:</span> <span class=n>LifecycleOwner</span><span class=p>,</span>
    <span class=n>presenter</span><span class=p>:</span> <span class=n>LineStationPresenter</span><span class=p>,</span>
    <span class=n>callback</span><span class=p>:</span> <span class=n>Callback</span><span class=p>,</span>
<span class=p>)</span> <span class=p>:</span> <span class=n>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span><span class=p>(</span><span class=n>binding</span><span class=p>.</span><span class=n>root</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>init</span> <span class=p>{</span>
        <span class=n>binding</span><span class=p>.</span><span class=n>lifecycleOwner</span> <span class=p>=</span> <span class=n>lifecycleOwner</span>
        <span class=n>binding</span><span class=p>.</span><span class=n>presenter</span> <span class=p>=</span> <span class=n>presenter</span>
        <span class=n>binding</span><span class=p>.</span><span class=n>callback</span> <span class=p>=</span> <span class=n>callback</span>
    <span class=p>}</span>

    <span class=k>fun</span> <span class=nf>bind</span><span class=p>(</span><span class=n>child</span><span class=p>:</span> <span class=n>StationListItem</span><span class=p>.</span><span class=n>Child</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>binding</span><span class=p>.</span><span class=n>child</span> <span class=p>=</span> <span class=n>child</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>或許你有看過一些教學或其他人會在改變 binding variable 後要 call <code>binding.executePendingBindings()</code> 觸發 UI 更新，但我們卻沒有這樣做。這是因為我們交了 <code>LifecycleOwner</code> 給 binding。如果我們交的 variable 是 <code>LiveData</code> 或 <code>StateFlow</code>，只要預先設定好 <code>LifecycleOwner</code> 就能自動觸發 UI 更新。這就是我們刻意在 <code>ViewHolder</code> 的 constructor 要求 <code>LifecycleOwner</code> 的原因。而 constructor 的 <code>binding.root</code> 就是從 binding object 取得 root view 的寫法（因為 <code>RecyclerView.ViewHolder</code> 的 constructor 需要 root view）。至於 <code>bind</code> method 就是讓 <code>ListAdapter#onBindViewHolder</code> 能夠提交當前 list item object 到 <code>ViewHolder</code>。</p>
<h2 id=adapter>Adapter<a hidden class=anchor aria-hidden=true href=#adapter>#</a></h2>
<p>之前準備了這麼多的東西就是為了寫本篇最主要的 class：<code>StationListAdapter</code>。首是是它的基本骨架：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>class</span> <span class=nc>StationListAdapter</span><span class=p>(</span>
    <span class=n>lifecycleOwner</span><span class=p>:</span> <span class=n>LifecycleOwner</span><span class=p>,</span>
    <span class=n>presenter</span><span class=p>:</span> <span class=n>LineStationPresenter</span><span class=p>,</span>
    <span class=n>callback</span><span class=p>:</span> <span class=n>Callback</span><span class=p>,</span>
<span class=p>)</span> <span class=p>:</span> <span class=n>ListAdapter</span><span class=p>&lt;</span><span class=n>StationListItem</span><span class=p>,</span> <span class=n>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span><span class=p>&gt;(</span><span class=n>StationListItem</span><span class=p>.</span><span class=n>DiffCallback</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>private</span> <span class=k>val</span> <span class=py>lifecycleOwner</span> <span class=p>=</span> <span class=n>WeakReference</span><span class=p>(</span><span class=n>lifecycleOwner</span><span class=p>)</span>
    <span class=k>private</span> <span class=k>val</span> <span class=py>presenter</span> <span class=p>=</span> <span class=n>WeakReference</span><span class=p>(</span><span class=n>presenter</span><span class=p>)</span>
    <span class=k>private</span> <span class=k>val</span> <span class=py>callback</span> <span class=p>=</span> <span class=n>WeakReference</span><span class=p>(</span><span class=n>callback</span><span class=p>)</span>

    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onCreateViewHolder</span><span class=p>(</span><span class=n>parent</span><span class=p>:</span> <span class=n>ViewGroup</span><span class=p>,</span> <span class=n>viewType</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span> <span class=p>{</span>
        <span class=n>TODO</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=k>override</span> <span class=k>fun</span> <span class=nf>getItemViewType</span><span class=p>(</span><span class=n>position</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Int</span> <span class=p>=</span> <span class=k>when</span> <span class=p>(</span><span class=n>getItem</span><span class=p>(</span><span class=n>position</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>TODO</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onBindViewHolder</span><span class=p>(</span><span class=n>holder</span><span class=p>:</span> <span class=n>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span><span class=p>,</span> <span class=n>position</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>TODO</span><span class=p>()</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>由於 <code>ViewHolder</code> 用了 <code>LifecycleOwner</code>、<code>LineStationPresenter</code>、<code>Callback</code>，所以我們在 <code>StationListAdapter</code> 的 constructor 傳入這些東西，好讓我們在 <code>onCreateViewHolder</code> 時能夠把它們傳入去 <code>ViewHolder</code>。而我們另外造了三個 <code>WeakReference</code> 把 constructor 帶進來的東西放入去是避免 memory leak。而 <code>ListAdapter</code> 的兩個 type argument 分別是 list item 和 <code>ViewHolder</code> 的 type。由於我們有兩個 <code>ViewHolder</code>，所以我們惟有選用 <code>RecyclerView.ViewHolder</code>。如果你的 <code>ListAdapter</code> 只有單一 <code>ViewHolder</code>，那可以直接用那個 <code>ViewHolder</code> type，這樣就能在 <code>onBindViewHolder</code> 直接用到那個 <code>ViewHolder</code> 而不用 type casting。當然你可以用 sealed class/interface 來避免強行 type casting。</p>
<p>接着我們開始寫 <code>getItemViewType</code>，我們以 layout XML 的 R class 來做 view type ID，這樣就保證不會撞號碼。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>override</span> <span class=k>fun</span> <span class=nf>getItemViewType</span><span class=p>(</span><span class=n>position</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Int</span> <span class=p>=</span> <span class=k>when</span> <span class=p>(</span><span class=n>getItem</span><span class=p>(</span><span class=n>position</span><span class=p>))</span> <span class=p>{</span>
    <span class=k>is</span> <span class=n>StationListItem</span><span class=p>.</span><span class=n>Group</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>.</span><span class=n>layout</span><span class=p>.</span><span class=n>station_list_line_item</span>
    <span class=k>is</span> <span class=n>StationListItem</span><span class=p>.</span><span class=n>Child</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>.</span><span class=n>layout</span><span class=p>.</span><span class=n>station_list_station_item</span>
    <span class=k>else</span> <span class=o>-&gt;</span> <span class=k>throw</span> <span class=n>UnsupportedOperationException</span><span class=p>(</span><span class=s2>&#34;Unsupported view type at position </span><span class=si>$position</span><span class=s2>&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>然後是 <code>onCreateViewHolder</code>，我們會按照 view type 決定 instantiate 那一個 <code>ViewHolder</code>。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>override</span> <span class=k>fun</span> <span class=nf>onCreateViewHolder</span><span class=p>(</span><span class=n>parent</span><span class=p>:</span> <span class=n>ViewGroup</span><span class=p>,</span> <span class=n>viewType</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span> <span class=p>{</span>
    <span class=k>val</span> <span class=py>inflater</span> <span class=p>=</span> <span class=n>LayoutInflater</span><span class=p>.</span><span class=n>from</span><span class=p>(</span><span class=n>parent</span><span class=p>.</span><span class=n>context</span><span class=p>)</span>
    <span class=k>return</span> <span class=k>when</span> <span class=p>(</span><span class=n>viewType</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>R</span><span class=p>.</span><span class=n>layout</span><span class=p>.</span><span class=n>station_list_line_item</span> <span class=o>-&gt;</span> <span class=n>LineItemViewHolder</span><span class=p>(</span>
            <span class=n>binding</span> <span class=p>=</span> <span class=n>StationListLineItemBinding</span><span class=p>.</span><span class=n>inflate</span><span class=p>(</span><span class=n>inflater</span><span class=p>,</span> <span class=n>parent</span><span class=p>,</span> <span class=k>false</span><span class=p>),</span>
            <span class=n>lifecycleOwner</span> <span class=p>=</span> <span class=n>requireNotNull</span><span class=p>(</span><span class=n>lifecycleOwner</span><span class=p>.</span><span class=k>get</span><span class=p>()),</span>
            <span class=n>presenter</span> <span class=p>=</span> <span class=n>requireNotNull</span><span class=p>(</span><span class=n>presenter</span><span class=p>.</span><span class=k>get</span><span class=p>()),</span>
            <span class=n>callback</span> <span class=p>=</span> <span class=n>requireNotNull</span><span class=p>(</span><span class=n>callback</span><span class=p>.</span><span class=k>get</span><span class=p>()),</span>
        <span class=p>)</span>
        <span class=n>R</span><span class=p>.</span><span class=n>layout</span><span class=p>.</span><span class=n>station_list_station_item</span> <span class=o>-&gt;</span> <span class=n>StationItemViewHolder</span><span class=p>(</span>
            <span class=n>binding</span> <span class=p>=</span> <span class=n>StationListStationItemBinding</span><span class=p>.</span><span class=n>inflate</span><span class=p>(</span><span class=n>inflater</span><span class=p>,</span> <span class=n>parent</span><span class=p>,</span> <span class=k>false</span><span class=p>),</span>
            <span class=n>lifecycleOwner</span> <span class=p>=</span> <span class=n>requireNotNull</span><span class=p>(</span><span class=n>lifecycleOwner</span><span class=p>.</span><span class=k>get</span><span class=p>()),</span>
            <span class=n>presenter</span> <span class=p>=</span> <span class=n>requireNotNull</span><span class=p>(</span><span class=n>presenter</span><span class=p>.</span><span class=k>get</span><span class=p>()),</span>
            <span class=n>callback</span> <span class=p>=</span> <span class=n>requireNotNull</span><span class=p>(</span><span class=n>callback</span><span class=p>.</span><span class=k>get</span><span class=p>()),</span>
        <span class=p>)</span>
        <span class=k>else</span> <span class=o>-&gt;</span> <span class=k>throw</span> <span class=n>UnsupportedOperationException</span><span class=p>(</span><span class=s2>&#34;Unsupported view type </span><span class=si>$viewType</span><span class=s2>&#34;</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>最後是 <code>onBindViewHolder</code>，由於我們用了 data binding，所以只需要提交那個 list item 進去 <code>ViewHolder</code> 就可以了。不過就算我們把 <code>ViewHolder</code> 用 sealed class/interface 包住都要替 list item 做 type casting，除非整個 list 只有一款 list item class。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>override</span> <span class=k>fun</span> <span class=nf>onBindViewHolder</span><span class=p>(</span><span class=n>holder</span><span class=p>:</span> <span class=n>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span><span class=p>,</span> <span class=n>position</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>when</span> <span class=p>(</span><span class=k>val</span> <span class=py>item</span> <span class=p>=</span> <span class=n>getItem</span><span class=p>(</span><span class=n>position</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>is</span> <span class=n>StationListItem</span><span class=p>.</span><span class=n>Group</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=n>holder</span> <span class=k>as</span> <span class=n>LineItemViewHolder</span><span class=p>).</span><span class=n>bind</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
        <span class=k>is</span> <span class=n>StationListItem</span><span class=p>.</span><span class=n>Child</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=n>holder</span> <span class=k>as</span> <span class=n>StationItemViewHolder</span><span class=p>).</span><span class=n>bind</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>現在 <code>StationListAdapter</code> 已經完成了，完整的 code 可以到 <a href=https://github.com/ericksli/eta-demo/tree/main/app/src/main/java/net/swiftzer/etademo/presentation/stationlist>GitHub repo 查閱</a>。下一篇會實作 ViewModel、<code>Fragment</code> 的部分，屆時就能完成車站列表頁的部分。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://eric.swiftzer.net/tags/2021-ithome-%E9%90%B5%E4%BA%BA%E8%B3%BD/>2021 iThome 鐵人賽</a></li>
<li><a href=https://eric.swiftzer.net/tags/android/>Android</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://eric.swiftzer.net/2021/10/2021-ithome-ironman-20-station-list-screen-2/>
<span class=title>« Prev Page</span>
<br>
<span>2021 iThome 鐵人賽 Day 20：Station list screen (2)</span>
</a>
<a class=next href=https://eric.swiftzer.net/2021/10/2021-ithome-ironman-18-navigation-2/>
<span class=title>Next Page »</span>
<br>
<span>2021 iThome 鐵人賽 Day 18：Navigation (2)</span>
</a>
</nav>
</footer><div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//efilm.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main><footer class=footer>
<span>&copy; 2022 <a href=https://eric.swiftzer.net/>EricLog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>