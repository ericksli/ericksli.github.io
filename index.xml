<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>EricLog</title><link>https://eric.swiftzer.net/</link><description>Recent content on EricLog</description><generator>Hugo -- 0.141.0</generator><language>zh-tw</language><lastBuildDate>Sun, 24 Nov 2024 15:20:00 +0800</lastBuildDate><atom:link href="https://eric.swiftzer.net/index.xml" rel="self" type="application/rss+xml"/><item><title>Missing parts when designing and implementing Android UI</title><link>https://eric.swiftzer.net/2024/11/missing-parts-when-designing-and-implementing-android-ui/</link><pubDate>Sun, 24 Nov 2024 15:20:00 +0800</pubDate><guid>https://eric.swiftzer.net/2024/11/missing-parts-when-designing-and-implementing-android-ui/</guid><description>&lt;p>昨天出席了 &lt;a href="https://gdg.community.dev/gdg-hong-kong/">GDG Hong Kong&lt;/a> 舉辦的 &lt;a href="https://gdg.community.dev/events/details/google-gdg-hong-kong-presents-devfest-2024-hong-kong/">DevFest 2024 Hong Kong&lt;/a> 並分享了「Missing parts when designing and implementing Android UI」。&lt;/p>
&lt;p>這個題目大致分為三個部分：&lt;/p>
&lt;ol>
&lt;li>一般在準備 Figma mockup 及由 mockup 實作成 Android app UI 時的常見問題，並以一 &lt;a href="https://www.figma.com/community/file/1116708627748807811/coffee-shop-mobile-app-design">Figma Community 免費範本&lt;/a>作例子&lt;/li>
&lt;li>Jetpack Compose accessibility&lt;/li>
&lt;li>Jetpack Compose UI testing，示範 Compose testing 搭配 Robolectric 及支援 Appium 的貼士&lt;/li>
&lt;/ol></description></item><item><title>AndroidX Navigation component for Jetpack Compose type safety</title><link>https://eric.swiftzer.net/2024/08/androidx-navigation-compose-type-safety/</link><pubDate>Sun, 18 Aug 2024 22:00:00 +0800</pubDate><guid>https://eric.swiftzer.net/2024/08/androidx-navigation-compose-type-safety/</guid><description>&lt;p>AndroidX Navigation component 是 Google 推出的 &lt;a href="https://www.youtube.com/watch?v=2k8x8V77CrU">single &lt;code>Activity&lt;/code> app&lt;/a> navigation library。本身是用 &lt;code>Fragment&lt;/code> 來做每一頁的內容，然後再用新的 Android resource type——navigation 來定義 navigation graph（即是聲明一個 navigation graph 內有什麼 &lt;code>Fragment&lt;/code>、打開 &lt;code>Fragment&lt;/code> 時要什麼參數和各 &lt;code>Fragment&lt;/code> 之間如何導覽的 XML 檔案）。如果加上 &lt;a href="https://developer.android.com/guide/navigation/use-graph/safe-args">Safe Args&lt;/a> Gradle plugin 的話就會按 navigation graph XML 檔案生成那些 Java code 去讓你在 &lt;code>Fragment&lt;/code> 內轉頁時調用，那就不會怕轉頁時漏了幾個參數沒有傳到，因為漏了的話就不能成功 compile。&lt;/p></description></item><item><title>Firebase Cloud Messaging legacy API</title><link>https://eric.swiftzer.net/2024/06/firebase-cloud-messaging-legacy-api/</link><pubDate>Sat, 01 Jun 2024 14:00:00 +0800</pubDate><guid>https://eric.swiftzer.net/2024/06/firebase-cloud-messaging-legacy-api/</guid><description>&lt;p>如果有用 Firebase Cloud Messaging (FCM) 或者其他關於 FCM 的第三方 SDK 的話應該會收到通知說 6 月 21 日會停用舊版的 FCM API（即是供 server 發送 notification 那個 API endpoint）。之後就要轉用 &lt;a href="https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages/send">HTTP v1 API&lt;/a>。&lt;/p></description></item><item><title>Android WebView 筆記</title><link>https://eric.swiftzer.net/2024/02/android-webview/</link><pubDate>Sat, 24 Feb 2024 11:45:00 +0800</pubDate><guid>https://eric.swiftzer.net/2024/02/android-webview/</guid><description>&lt;p>好幾年都沒有特別去用 Android 的 &lt;code>WebView&lt;/code>，近期工作需要用到 &lt;code>WebView&lt;/code>，所以特別去查一下並將資料放在這篇文章內方便日後翻查。&lt;/p>
&lt;h2 id="androidx-webkit">AndroidX WebKit&lt;/h2>
&lt;p>AndroidX 其實有 WebKit 的 artifact &lt;a href="https://maven.google.com/web/index.html#androidx.webkit:webkit">&lt;code>androidx.webkit:webkit&lt;/code>&lt;/a>，但不是把整個 browser 加到 app 入面（&lt;code>WebView&lt;/code> 實際在用的 web browser 是由 &lt;a href="https://play.google.com/store/apps/details?id=com.google.android.webview">Google Play Store 提供&lt;/a>，並可以 developer options 切換），而是把部分較新的 &lt;code>WebView&lt;/code> 功能加個檢查 function，如果目前的 &lt;code>WebView&lt;/code> 支援那個功能的話就可以執行這部分的 code。&lt;/p></description></item><item><title>Android 14 migration</title><link>https://eric.swiftzer.net/2024/02/android-14-migration/</link><pubDate>Fri, 02 Feb 2024 00:05:00 +0800</pubDate><guid>https://eric.swiftzer.net/2024/02/android-14-migration/</guid><description>&lt;p>最近把 &lt;a href="https://play.google.com/store/apps/details?id=net.swiftzer.metroride">MetroRide&lt;/a> 的 API level 升到 34 (&lt;a href="https://developer.android.com/about/versions/14">Android 14&lt;/a>)，中間發現了一些問題，在這裏記錄一下。&lt;/p>
&lt;h2 id="foreground-service">Foreground service&lt;/h2>
&lt;p>MetroRide 有用到 AndroidX WorkManager 來下載離線資料並放到 SQLite database 內，而且開了 foreground service。在 Android 14 規定要加 permission &lt;code>FOREGROUND_SERVICE_DATA_SYNC&lt;/code> 標明 foreground service 的目的。&lt;/p></description></item><item><title>Android pseudolocale</title><link>https://eric.swiftzer.net/2023/07/android-pseudolocale/</link><pubDate>Fri, 14 Jul 2023 23:40:00 +0800</pubDate><guid>https://eric.swiftzer.net/2023/07/android-pseudolocale/</guid><description>&lt;p>在處理 app UI 多國語言時，我們不時要留意是不是預留了足夠空間來顯示文字。一般而言，中文內容通常都比其他語言短，你的 UI 可能看起來沒有問題，但換到其他寫得比較長的語言就可能不夠位顯示。但在開發初期可能還未開始翻譯，只有英文版，未必能在早期察覺這個問題。&lt;/p></description></item><item><title>Android 13 Per-app Language Preferences</title><link>https://eric.swiftzer.net/2023/01/android-13-per-app-language-preferences/</link><pubDate>Wed, 25 Jan 2023 14:27:00 +0800</pubDate><guid>https://eric.swiftzer.net/2023/01/android-13-per-app-language-preferences/</guid><description>&lt;p>最近抽點時間把 &lt;a href="https://play.google.com/store/apps/details?id=net.swiftzer.metroride">MetroRide&lt;/a> 參照 &lt;a href="https://github.com/android/nowinandroid">Now in Android&lt;/a> 示範項目更新一下，例如改用 TOML 版的 &lt;a href="https://docs.gradle.org/current/userguide/platforms.html">version catalog&lt;/a>（之前是用 Kotlin DSL）、轉用 &lt;code>includeBuild&lt;/code> 加 convention plugin 取代之前把 plugin 放在 &lt;code>buildSrc&lt;/code> 內、更新 dependency 版本和把 target SDK 升到最新（即是 Android 13；API level 33）。這次想分享的是適配 Android 13 的 per-app language preferences（個別應用程式語言偏好）功能。&lt;/p></description></item><item><title>裝備</title><link>https://eric.swiftzer.net/gear/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0800</pubDate><guid>https://eric.swiftzer.net/gear/</guid><description>&lt;h2 id="現正持有">現正持有&lt;/h2>
&lt;h3 id="相機">相機&lt;/h3>
&lt;h4 id="olympus-om-d-e-m10httpsomsystemcomhkproductdslrem10indexhtml">&lt;a href="https://omsystem.com.hk/product/dslr/em10/index.html">Olympus OM-D E-M10&lt;/a>&lt;/h4>
&lt;p>這是我第一部可換鏡頭相機，於 2015 年 6 月購入。本來是考慮 &lt;a href="https://www.sony.com.hk/zh/electronics/interchangeable-lens-cameras/ilce-6000-body-kit">Sony α6000&lt;/a>，但最後因為價錢和 M4/3 系統鏡頭數量所以最後買了 E-M10。這部相機機身是復古造型，非常好看。&lt;a href="https://www.youtube.com/watch?v=8pRhtJPcbrM">Live Composite 功能&lt;/a>夠特別。但就只有三軸防震（Olympus 後來推出的機型都有五軸防震）、高 ISO 下有很多雜訊和 1080p 拍片畫質很差。用了七年左右還未壞，只是間中出現入錯拍錯 mode。即是 mode dial 在開機前選了 A mode 然後開機，相機會顯示當前是 S mode。重新開機或者把 mode dial 切換到 S mode 然後到 A mode 又會回復正常。&lt;/p></description></item><item><title>Jetpack Compose Navigation component sub-graph</title><link>https://eric.swiftzer.net/2022/07/jetpack-compose-navigation-component-sub-graph/</link><pubDate>Wed, 27 Jul 2022 21:30:00 +0800</pubDate><guid>https://eric.swiftzer.net/2022/07/jetpack-compose-navigation-component-sub-graph/</guid><description>&lt;p>這次&lt;a href="https://eric.swiftzer.net/2022/07/jetpack-compose-migration-1/">遷移到 Compose&lt;/a> 時特別花了時間試用 Compose 的 Navigation component，終於弄清 nested graph 的意義。其實 Compose 的 Navigation component 底層都是跟 XML 版的 Navigation component 一樣，只是底層多了以 route 形式的處理。以往的說明文件在介紹 &lt;a href="https://developer.android.com/guide/navigation/navigation-nested-graphs">nested navigation graph&lt;/a> 時沒有太具體說明 nested graph 背後的意義，看完之後可能覺得只是用來避免單一 XML 檔過長而拆成不同 sub-graph。但其實在 deep link 時是有特別意義。&lt;/p></description></item><item><title>Jetpack Compose 遷移 (2)</title><link>https://eric.swiftzer.net/2022/07/jetpack-compose-migration-2/</link><pubDate>Tue, 26 Jul 2022 14:00:00 +0800</pubDate><guid>https://eric.swiftzer.net/2022/07/jetpack-compose-migration-2/</guid><description>&lt;p>&lt;a href="https://eric.swiftzer.net/2022/07/jetpack-compose-migration-1/">上一篇&lt;/a>提過如何將 &lt;a href="https://play.google.com/store/apps/details?id=net.swiftzer.metroride">MetroRide&lt;/a> 由傳統 view system 遷移到 Jetpack Compose。但一篇又太長，所以分拆成兩篇。&lt;/p>
&lt;h2 id="dependency-injection">Dependency injection&lt;/h2>
&lt;p>按照官方的建議，composable function 要用到的 dependency 應該由 caller 經參數提供。然後就是由外層一直傳進去。至於那個外層最遠可以去到 &lt;code>Activity&lt;/code> 或者 &lt;code>Fragment&lt;/code>。由於 composable function 就是 top-level function，沒有 class 包住，所以平常用開的 Dagger 或者 Koin 之類的 DI library 都無辦法輕易地在 composable function 經 DI 拿到 dependency。如果以 Dagger Hilt 來計，目前是有這幾種方式：&lt;/p></description></item></channel></rss>