<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>EricLog</title><link>https://eric.swiftzer.net/</link><description>Recent content on EricLog</description><generator>Hugo -- gohugo.io</generator><language>zh-Hant-HK</language><lastBuildDate>Sat, 14 Nov 2020 18:52:34 +0800</lastBuildDate><atom:link href="https://eric.swiftzer.net/index.xml" rel="self" type="application/rss+xml"/><item><title>Jetpack DataStore 搭配 kotlinx.serialization Protobuf</title><link>https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/</link><pubDate>Sat, 14 Nov 2020 18:52:34 +0800</pubDate><guid>https://eric.swiftzer.net/2020/11/androidx-datastore-with-kotlinx-serialization-protobuf/</guid><description>上月 kotlinx.serialization 出了 1.0 版。除了支援 JSON 之外，還有支援 Protocol Buffers (Protobuf)，而且還是跨平台支援。而在前一個月 Android 出了 Jetpack DataStore，它是一個用來取</description></item><item><title>Conventional Commits 和 commitlint</title><link>https://eric.swiftzer.net/2020/08/conventional-commits-commitlint/</link><pubDate>Mon, 24 Aug 2020 23:27:07 +0800</pubDate><guid>https://eric.swiftzer.net/2020/08/conventional-commits-commitlint/</guid><description>Conventional Commits 是一個簡單的 Git commit message 約定，用來規定 commit message 的寫法。Git 本身就沒有規定 commit message 的內容格式，所以不同人會有不同的做法。如果 repository 只是有一個或幾個人用的話</description></item><item><title>Java 量度單位 (JSR 363 Units of Measurement API)</title><link>https://eric.swiftzer.net/2020/08/javax-measure/</link><pubDate>Thu, 13 Aug 2020 23:50:59 +0800</pubDate><guid>https://eric.swiftzer.net/2020/08/javax-measure/</guid><description>在日常生活中，我們都會用到不同的量度單位。例如重量有時會用公斤 (kg)，有時會用磅 (lb)，有時又會用斤之類。如果在 Java 上表示這些數值，用 in</description></item><item><title>Kotlin Annotation Processor</title><link>https://eric.swiftzer.net/2020/04/kotlin-annotation-processor/</link><pubDate>Mon, 27 Apr 2020 23:34:08 +0800</pubDate><guid>https://eric.swiftzer.net/2020/04/kotlin-annotation-processor/</guid><description>如果有做過 Android 開發的話應該都有用過 annotation processor（又稱 codegen），即是在 build.gradle 入面要用 annotationProcessor 或者 kapt 的那些 dependency。用法大概是在</description></item><item><title>Moshi Kotlin Codegen + R8 出現 parameter type is null</title><link>https://eric.swiftzer.net/2020/03/moshi-r8-parameter-type-is-null/</link><pubDate>Sun, 15 Mar 2020 11:10:42 +0800</pubDate><guid>https://eric.swiftzer.net/2020/03/moshi-r8-parameter-type-is-null/</guid><description>Moshi 是一個 JSON serialization/deserialization 的 library。和 Gson 不同的是它提供了 Kotlin Codegen，它可以生成 serialization/deserialization 的 adapter class，所以可以避免使用 reflection，而且 adapter</description></item><item><title>Firebase Crashlytics 的 CrashlyticsOrgIdException 解決方法</title><link>https://eric.swiftzer.net/2020/03/firebase-crashlyticsorgidexception/</link><pubDate>Sat, 14 Mar 2020 11:55:17 +0800</pubDate><guid>https://eric.swiftzer.net/2020/03/firebase-crashlyticsorgidexception/</guid><description>最近為自己的 app 加入 Firebase Crashlytics SDK beta（即是使用 Google 的 Firebase Crashlytics Gradle plugin 而不是用 Fabric 那個），但在 build release APK 時出現下面的錯誤： java.io.IOException: com.google.firebase.crashlytics.buildtools.exception.CrashlyticsOrgIdException: Could not fetch Crashlytics Org Id &amp;gt; com.google.firebase.crashlytics.buildtools.exception.CrashlyticsOrgIdException: Could not fetch Crashlytics Org Id &amp;gt; Could not fetch</description></item><item><title>Firebase Cloud Messaging</title><link>https://eric.swiftzer.net/2020/02/firebase-cloud-messaging/</link><pubDate>Sat, 29 Feb 2020 14:07:18 +0800</pubDate><guid>https://eric.swiftzer.net/2020/02/firebase-cloud-messaging/</guid><description>最近工作需要做 Firebase Cloud Messaging (FCM) 整合，發現了向 Firebase API 直接送出 push 的 HTTP request 都可以生成不同種類的 message。 如果要整合到 Android 的話，需要建立一個新的 Service class 並繼承自</description></item><item><title>Android App Icon 規格</title><link>https://eric.swiftzer.net/2019/07/android-app-icon-specification/</link><pubDate>Sat, 20 Jul 2019 13:43:37 +0800</pubDate><guid>https://eric.swiftzer.net/2019/07/android-app-icon-specification/</guid><description>一個 app 的第一印象應該是它的 app icon (launcher icon)。在 Android，在不同的時期前後出了好幾個 app icon 規格。但是 Android 介紹不同種類的 app icon 的文件放得非常分散</description></item><item><title>用 Google Apps Script 發送電郵</title><link>https://eric.swiftzer.net/2019/04/google-apps-script-send-email/</link><pubDate>Sun, 14 Apr 2019 15:08:36 +0800</pubDate><guid>https://eric.swiftzer.net/2019/04/google-apps-script-send-email/</guid><description>在上一篇為大家介紹了如何用 Google Apps Script 建立 Google Calendar event。這一次就示範用 Google Apps Script 發送電郵（即是 mail merge）。 準備內容 上次我們用 2019 年香港公眾假期作例</description></item><item><title>OpenRefine GREL 筆記</title><link>https://eric.swiftzer.net/2019/02/openrefine-snippets/</link><pubDate>Wed, 20 Feb 2019 23:53:05 +0800</pubDate><guid>https://eric.swiftzer.net/2019/02/openrefine-snippets/</guid><description>&lt;p>&lt;a href="http://openrefine.org/">OpenRefine&lt;/a> 是一個開源的工具，用作檢視資料、加工處理後作其他用途。簡單的例子有一堆街名，部分街名用了全寫、部分用了縮寫，想將它們全部統一用全寫。它的定位是介乎 Excel 和自己寫程式之間。有時資料用 Excel 不太方便處理，但如果自己寫程式處理又因為程式只會用一次，感覺太麻煩。OpenRefine 相信可以解決到你的需要。&lt;/p>
&lt;figure>
&lt;img src="text-facet.png"/> &lt;figcaption>
Text facet 功能可以批量修改相近的資料，而不用寫程式
&lt;/figcaption>
&lt;/figure>
&lt;p>OpenRefine 內置了一種程式語言，名為 &lt;a href="https://github.com/OpenRefine/OpenRefine/wiki/General-Refine-Expression-Language">General Refine Expression Language (GREL)&lt;/a>，和 Excel 可以用公式差不多。我們用 OpenRefine 就是透過這種語言來把資料批量轉換成自己想要的東西。&lt;/p>
&lt;p>值得一提的是 OpenRefine 以前由 Google 負責維護，所以介面會有以前 Google 產品的影子。&lt;/p></description></item></channel></rss>