<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AndroidX Navigation component for Jetpack Compose type safety | EricLog</title>
<meta name=keywords content="Android"><meta name=description content="AndroidX Navigation component 是 Google 推出的 single Activity app navigation library。本身是用 Fragment 來做每一頁的內容，然後再用新的 Android resource type——navigation 來定義 navigation graph（即是"><meta name=author content><link rel=canonical href=https://eric.swiftzer.net/2024/08/androidx-navigation-compose-type-safety/><link crossorigin=anonymous href=/assets/css/stylesheet.014d92f7e42768013bc6e6c6aaf7562cad235ef48b65d729ba2e6b2ceb3a58e1.css integrity="sha256-AU2S9+QnaAE7xubGqvdWLK0jXvSLZdcpui5rLOs6WOE=" rel="preload stylesheet" as=style><link rel=icon href=https://eric.swiftzer.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://eric.swiftzer.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://eric.swiftzer.net/favicon-32x32.png><link rel=apple-touch-icon href=https://eric.swiftzer.net/apple-touch-icon.png><link rel=mask-icon href=https://eric.swiftzer.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://eric.swiftzer.net/2024/08/androidx-navigation-compose-type-safety/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@300&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-D93F946T73"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D93F946T73",{anonymize_ip:!1})}</script><meta property="og:title" content="AndroidX Navigation component for Jetpack Compose type safety"><meta property="og:description" content="AndroidX Navigation component 是 Google 推出的 single Activity app navigation library。本身是用 Fragment 來做每一頁的內容，然後再用新的 Android resource type——navigation 來定義 navigation graph（即是"><meta property="og:type" content="article"><meta property="og:url" content="https://eric.swiftzer.net/2024/08/androidx-navigation-compose-type-safety/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-18T22:00:00+08:00"><meta property="article:modified_time" content="2024-08-18T22:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="AndroidX Navigation component for Jetpack Compose type safety"><meta name=twitter:description content="AndroidX Navigation component 是 Google 推出的 single Activity app navigation library。本身是用 Fragment 來做每一頁的內容，然後再用新的 Android resource type——navigation 來定義 navigation graph（即是"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://eric.swiftzer.net/posts/"},{"@type":"ListItem","position":2,"name":"AndroidX Navigation component for Jetpack Compose type safety","item":"https://eric.swiftzer.net/2024/08/androidx-navigation-compose-type-safety/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AndroidX Navigation component for Jetpack Compose type safety","name":"AndroidX Navigation component for Jetpack Compose type safety","description":"AndroidX Navigation component 是 Google 推出的 single Activity app navigation library。本身是用 Fragment 來做每一頁的內容，然後再用新的 Android resource type——navigation 來定義 navigation graph（即是","keywords":["Android"],"articleBody":"AndroidX Navigation component 是 Google 推出的 single Activity app navigation library。本身是用 Fragment 來做每一頁的內容，然後再用新的 Android resource type——navigation 來定義 navigation graph（即是聲明一個 navigation graph 內有什麼 Fragment、打開 Fragment 時要什麼參數和各 Fragment 之間如何導覽的 XML 檔案）。如果加上 Safe Args Gradle plugin 的話就會按 navigation graph XML 檔案生成那些 Java code 去讓你在 Fragment 內轉頁時調用，那就不會怕轉頁時漏了幾個參數沒有傳到，因為漏了的話就不能成功 compile。\nNavigation component for Compose 的 navigation 方式 AndroidX Navigation 有推出了 Compose 版，其實核心都是沿用原本處理 Fragment navigation 的那些 code。但每頁的「代號」由 Android resource ID 改為網址式的 string 表示（叫做 route）。轉頁在 AndroidX Navigation Compose 的理解就是按網址找到對應的 composable function 去 call 然後在網址抽取打開該頁要用到的參數。用法大概就是這樣：\ncomposable(\"shop/{shopId}?promoCode={promoCode}\") { backStackEntry -\u003e val shopId: String? = backStackEntry.arguments?.getString(\"shopId\") val promoCode: String? = backStackEntry.arguments?.getString(\"promoCode\") // 該頁顯示的內容 Column { Text(shopId.orEmpty()) Text(promoCode.orEmpty()) } } 可以見到 shop/{shopId}?showPromo={showPromo} 就是該頁面的「代號」，而 shopId 是必需而 showPromo 是可選。要打開該頁的話就要用 navController.navigate：\nnavController.navigate(\"shop/abc123?promoCode=foo\") 如果要傳更多參數就用 / （必需參數）和 \u0026 （可選參數）串接起來。這個網址單純就是為了表達不同的 route 和要傳遞的參數，跟 RESTful 沒有關係。\n轉用網址來代表頁面的好處是方便 multiplatform。因為 resource ID 和 Parcelable 是 Android 才有（Fragment 版 AndroidX Navigation 是可以傳 Parcelable 參數），加上把參數塞到網址就可以很簡單地處理到 deep link。但對 Android 開發者而言是不太習慣，尤其是沒有簡單直接方法傳 Parcelable 參數和 Fragment Result API 功能。可能因為 Google 的目標是想把 AndroidX Navigation 在 web app 都能用所以就把這些原本 Fragment 版有的東西都收起不做，然後直接在文檔寫不建議傳複雜 object，應該要傳 object 的 ID 然後再從 database 之類的地方拿 data，因為怕會在 Activity.onSaveInstanceState 塞爆。我覺得防止塞爆是合理，因為要考慮到 app 放在 background 後被 system kill app 然後 user 再從 recents 開 app 需要還原 kill app 前的狀態（雖然很多 Android developer 不去管這個問題，然後以為現在的裝置有很多 RAM 不會輪到自己的 app 被 kill，被 kill 之後重開 app 還原不了先前的狀態就爛掉）。但如果只是傳一些簡單的 object 要動用到 database/file system 開一個檔案又太勞師動眾。（下面會示範如何傳 Parcelable 參數）\n如果想了解更多 Compose 的 Navigation component 使用方式可以查閱 2022 年寫的「Jetpack Compose Navigation component sub-graph」一文。\nType safety 的 navigation 方式 在 AndroidX Navigation 2.8.0 開始（目前是 beta）Compose Navigation 可以改用相對比較 type safety 的方法定義 route。其實之前已經有其他人用 Kotlin Symbol Processing (KSP) 去生成 Kotlin code 去令 Compose Navigation 做到 type safety 的效果（生成那串網址、從 back stack entry 拿到參數的部分），但 Google 就不用 KSP 而是借用 Kotlin Serialization Gradle plugin 生成的 $serializer class 來做到同樣效果（其實單純做 navigation route 是不用再加 JSON/ProtoBuf 之類的 artifact）。我們會以下面那個 data class 做例子。這個 data class 有兩個 property，就是那個 route 的兩個參數。如果沒有 default value 就是必需，相反就是可選參數。\n@Serializable data class StationDetailDestination( val id: Int: Int = -1, val lrlStopId: Int = -1, ) 如果這個頁面沒有參數要傳就改用 object/data object 再配搭 @Serializable。\n之後 composable 的寫法改為傳 type 而不再傳 route 和 arguments。\ncomposable\u003cStationDetailDestination\u003e( deepLinks = listOf( navDeepLink { uriPattern = \"https://lrnt.mtr.com.hk/moblink/?station_id={lrlStopId}\" }, ), ) { // 內容 } 之前的寫法：\ncomposable( route = \"stationDetail/{id}\", arguments = listOf( navArgument(\"id\") { type = NavType.IntType defaultValue = -1 }, navArgument(\"lrlStopId\") { type = NavType.IntType defaultValue = -1 }, ), deepLinks = listOf( // 略 ), ) { // 內容 } 新寫法不用再傳 route 和 arguments 是因為 Navigation component 改為讀取 Kotlin Serialization Gradle plugin 生成的 code。當 class 被加了 @Serializable 後，Kotlin Serialization Gradle plugin 會生成 $serializer class。把 StationDetailDestination 的 JVM bytecode decompile 後會找到這段內容：\nstatic { PluginGeneratedSerialDescriptor var0 = new PluginGeneratedSerialDescriptor( \"net.swiftzer.metroride.app.station.detail.StationDetailDestination\", (GeneratedSerializer) INSTANCE, 2 ); var0.addElement(\"id\", true); var0.addElement(\"lrlStopId\", true); descriptor = var0; $stable = 8; } 如果我們 call StationDetailDestination.serializer().descriptor 的話可以找回那個 data class 的名稱和有什麼 property：\nval descriptor = StationDetailDestination.serializer().descriptor println(descriptor.serialName) for (i in 0 until descriptor.elementsCount) { println(\"${descriptor.getElementName(i)}, ${descriptor.getElementDescriptor(i).kind}\") } 以下是 output：\nnet.swiftzer.metroride.app.station.detail.StationDetailDestination id, INT lrlStopId, INT 所以 Navigation component 就能憑以上的方法生成出以往要人手寫的 route 和 arguments（對，都是沿用之前以網址形式做 navigation，只是你不會直接看到那個網址 route）。\n要打開剛才那頁就這樣寫：\nnavController.navigate(StationDetailDestination(id = 123)) 以上的 navigate 會生成出這樣的 deep link 網址：\nandroid-app://androidx.navigation/net.swiftzer.metroride.app.station.detail.StationDetailDestination?id=123\u0026lrlStopId=-1 Route 名前面那部分就是 data class/object 的全名。Deep link 前面那段 android-app://androidx.navigation/ 就是 Navigation component 專屬的 deep link 前綴。\n至於如何讀取傳入 route 的參數？Navigation component 提供了 toRoute function 來讓你取回填好參數的 object。\n以下是 NavBackStackEntry 版：\ncomposable\u003cStationDetailDestination\u003e( // 略 ) { backStackEntry -\u003e val args: StationDetailDestination = backStackEntry.toRoute\u003cStationDetailDestination\u003e() println(args.id) // Int } 以下是 SavedStateHandle 版：\n@HiltViewModel class StationDetailViewModel @Inject constructor( savedStateHandle: SavedStateHandle, ) : ViewModel() { private val args: StationDetailDestination = savedStateHandle.toRoute\u003cStationDetailDestination\u003e() init { println(args.id) // Int } } 而 sub-graph 都是同樣做法，不再傳 string：\n@Serializable data object StationGraph @Serializable data object StationListDestination navigation\u003cStationGraph\u003e(startDestination = StationListDestination) { composable\u003cStationListDestination\u003e { // 略 } } Parcelable 要在 Navigation component Compose 傳 Parcelable 的話是比較麻煩，即使有了 type safety 寫法都沒有用，仍然要手寫一段 code 才能做到。\n下面示範了要傳遞一個 Reason enum 到 ScanErrorDestination 的寫法：\n@Parcelize @Serializable enum class Reason : Parcelable { UnsupportedCard, TagLost, } @Serializable data class ScanErrorDestination(val reason: Reason) fun NavGraphBuilder.scanErrorScreen( navigateUp: () -\u003e Unit, ) { composable\u003cScanErrorDestination\u003e( typeMap = ScanErrorScreenMap, // 之後會有這段 code ) { backStackEntry -\u003e val args = backStackEntry.toRoute\u003cScanErrorDestination\u003e() ScanErrorScreen( reason = args.reason, modifier = Modifier.fillMaxSize(), navigateUp = navigateUp, ) } } 上面 composable 多了一個 typeMap 參數，這個就是用來處理 Parcelable 的部分。以下是 ScanErrorScreenMap 的內容：\nval NavigationProtoBuf = ProtoBuf { encodeDefaults = false } val ReasonType = object : NavType\u003cReason\u003e(isNullableAllowed = false) { override fun get(bundle: Bundle, key: String): Reason? = BundleCompat.getParcelable(bundle, key, Reason::class.java) override fun put(bundle: Bundle, key: String, value: Reason) { bundle.putParcelable(key, value) } override fun serializeAsValue(value: Reason): String = NavigationProtoBuf.encodeToHexString(value) override fun parseValue(value: String): Reason = NavigationProtoBuf.decodeFromHexString\u003cReason\u003e(value) } val ScanErrorScreenMap = mapOf(typeOf\u003cReason\u003e() to ReasonType) ScanErrorScreenMap 就是用來定義 ScanErrorDestination 內的 property 如果有非 Navigation component 直接支援的 type 時要用對應的 NavType 來做 serialization/deserialization。NavType 簡單來講就是寫 serialization/deserialization 成 Parcelable 和 String 的實際操作部分。\n先講 Parcelable，它就是平時轉頁時會用的 serialization 形式，對應的 function 是 get 和 put。只要在那個 enum 加上 @Parcelize 和 implement Parcelable 然後再 call 對應的 Bundle function 就做到。\n另外兩個 function serializeAsValue 和 parseValue 是要把那個 enum 轉成 string 形式，它是對應 deep link（估計亦是日後支援 multiplatform 的處理方法，因為 Parcelable 是 Android 獨有的東西）。我就把那個 enum 用 Kotlin Serialization 轉成 ProtoBuf 十六進制 string 表示，你亦可以用 JSON 之類，但記得要做 URI encode/decode。\n以前例子是傳 enum，其實大可傳 enum value 的 ordinal，這樣就不用寫那麼多 code。但如果是 data class 的話都是要這樣寫。\n另外，如果在 ViewModel 內想透過 SavedStateHandle 獲取參數的話，要在 SavedStateHandle.toRoute 補回 typeMap 參數。NavBackStackEntry.toRoute 不用是因為 NavBackStackEntry 能找到 typeMap。\nprivate val args = savedStateHandle.toRoute\u003cScanErrorDestination\u003e( typeMap = ScanErrorScreenMap, ) Analytics 如果要做 screen view 式的 event tracking 而又不想逐頁加 code，可以 collect NavHostController.currentBackStackEntryFlow 來得知轉頁並在這個時候做 event tracking。下面是用 Firebase Analytics 做例子：\nLaunchedEffect(navController) { navController.currentBackStackEntryFlow.collectLatest { backStackEntry -\u003e backStackEntry.destination.route?.let { Firebase.analytics.logEvent(FirebaseAnalytics.Event.SCREEN_VIEW) { param(FirebaseAnalytics.Param.SCREEN_CLASS, it) } } } } 如果用上面那個例子的話，backStackEntry.destination.route 其實就是 net.swiftzer.metroride.app.station.detail.StationDetailDestination?id={id}\u0026lrlStopId={lrlStopId}，不會有參數的值。\n是否完全 type safefy？ 其實上面的 code 都示範了 deep link 的話仍然是要人手寫，連同 Android manifest 的 deep link 都要自己寫，所以在 compile 時不能察覺寫錯（如果用 XML 版的話是有半自動方法生成 ）。所以 type safety 只是針對之前手寫 route 要聲明參數和讀取參數的部分而已。總體效果不如以前 XML 般，有不少地方仍要手寫 code 而且不是 compile 時檢查，例如 deep link 和 NavType adapter。\n安全問題 今天逛 Reddit 發現了一篇名為「Russian hackers destroy Jetpack Navigation from its very core, turning best practice into security vulnerability in the blink of an eye」的文章，內容是連結到 Android Jetpack Navigation: Go Even Deeper。大意是如果你的 app 用了 AndroidX Navigation component for Compose 的話其實是可以讓人進入 NavHost 內任意一頁。\n按文章內容所描述，進入任意一頁的方法是找出放了 NavHost 的那個 Activity，然後用 Intent 開它，開的時候要附帶 data Uri，data 內容就是 Navigation component 自動生成的 route（即是 android-app://androidx.navigation/ 開首的網址）。其實不用另外做另一個 app 去 call Intent.startActivity，直接用 Android Debug Bridge (adb) 都可以：\nadb shell am start -W -a android.intent.action.VIEW -d \"android-app://androidx.navigation/net.swiftzer.metroride.app.setting.SettingsDestination\" net.swiftzer.metroride/net.swiftzer.metroride.app.entrypoint.MainActivity 這樣就可以直接開到 MetroRide 的設定頁。相信這對需要寫 end-to-end test 的人是個好消息，是一個 feature 而不是 bug。但如果你的 app 有部分頁面是需要登入後才能看的話這就比較尷尬（如果你不是在每頁都加登入檢查的話），因為這個方法可以繞過登入頁。\n其實能夠打開到設定頁的原因是因為 NavController 會拿 Activity.intent 去檢查 graph 內有沒有頁面能對應到這個 deep link（Activity.intent.data 就是 deep link URI），而那些由 Navigation component 自行生成的 route（即是 android-app://androidx.navigation/ 開首的網址）都會被 match 到。結果就能中門大開隨意進入 NavHost 內任何一頁。\nNavController 那一句 handleDeepLink 但似乎 Google 未修正這個問題，如果想馬上解決的話除了不用 Navigation component 之外就是把 Intent.data 清走。\n在 Activity 的 onCreate（在 setContent 前）加入這個 if：\nif (intent.data?.scheme == \"android-app\" \u0026\u0026 intent.data?.authority == \"androidx.navigation\") { intent.data = null } 如果 Activity 本身有設定 launch mode 是 singleTop 的話，亦應在 onNewIntent 刪走 Intent.data。\n這篇文章其實有示範到其中一頁有個 WebView 而 WebView 載入的網址是從開那頁的參數提供並且那個 WebView 會在 request header 加入 token，結果透過這個方法就能拿到 token。這個其實應該在每次加入 token 前就要檢查一次 request URL 是不是指定的 URL 才加入 token 的 request header。如果想加強 JavaScript 與 native app 雙向溝通安全性的話可以參考 Android WebView 筆記。\n結語 我覺得很多 Android/iOS developer 在做 navigation 時沒有像那些 backend framework 處理 request 的思維。一般那些 backend framework 在處理 request/response 時都會經過一些 middleware，例如你可以定義一個 middleware 用來檢查用戶是否已登入，然後把它套在需要登入後才能進入的 route。這個 middleware 的大概內容是如果沒有登入就重定向到登入頁，然後直接 output response，不用再交去下一個 middleware 或者是該 route 對應的 controller。這其實跟 OkHttp 的 interceptor 相似。背後的 design pattern 是 Chain of Responsibility，是 Gang of Four Design Patterns 內的 pattern。\nGoogle 將登入後才能進入否則重定向稱為 conditional navigation。它建議先讓用戶進入受限頁面，然後再用 Activity 層級開一個 UserViewModel，入面決定用戶是否已登入。而在受限頁面的 onViewCreated 就 observe UserViewModel 外露的是否已登入 LiveData。當發現未登入就馬上重定向到登入頁（準碓來說是在在受限頁面上顯示登入頁，沒有清除 back stack）。正因為沒有清除 back stack，用戶可以在登入頁按返回鍵回到之前的受限頁面。為了防止不斷重定向，它在受限頁面的 SavedStateHandle 加了一個 boolean flag 表明用戶是否成功登入，然後在受限頁面檢查那個 boolean flag 防止不斷在兩頁之間重定向。當然，今時今日不會有人這樣寫，因為兩個 ViewModel 之間通訊是很麻煩的事。通常都是用 dependency injection graph 加上一個能共用 instance 的 class 然後在入面放那些是否已登入的 Flow/LiveData/Observable。但 Google 這個提議最大問題是當頁面一多就很難 scale，因為它要求每頁都要加檢查的 code。\n如果我們沿用 AndroidX Navigation component 又想做到類似 middleware 的效果，大概就是弄一個 suspending function 包起 navController.navigate，在那個 suspending function 內檢查要 navigate 的 route 有沒有 middleware 要執行，有的話就逐個執行。如果最終確認是可以直接進入目標頁面那就可以執行 navController.navigate。如果是要重定向的話就要為重定向頁做同樣的 middleware 執行動作，直到找到最終目的地為止。而用 suspending function 的原因是那些 middleware 可能需要做 I/O 動作，不像 navController.navigate 可以馬上完成。而 NavHost 外面要加一個載入畫面，當執行 middleware 時就蓋在 NavHost 上面不能讓用戶按到畫面其他地方。這樣就不用每一頁都要再檢查一次用戶是否已登入，因為在進入前已經被 middleware 檢查過。\n很多 navigation library 偏向是補強 AndroidX Navigation component 欠缺生成 boilerplat code 的功能、或者令整個 app 變得更 MVI。反而中國出品的 navigation library 會做這類接近 middleware 的東西，但不知道有沒有考慮非同步的問題。它們甚至能做到由 backend 控制 navigation 的目的地（例如因應 A/B testing、feature flag 的值在 navigation 時開啟不同頁面）。\n參考 Navigation Compose meet Type Safety Type-Safe Navigation with the OFFICIAL Compose Navigation Library Android Jetpack Navigation: Go Even Deeper TheRouter ","wordCount":"4417","inLanguage":"zh-tw","datePublished":"2024-08-18T22:00:00+08:00","dateModified":"2024-08-18T22:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://eric.swiftzer.net/2024/08/androidx-navigation-compose-type-safety/"},"publisher":{"@type":"Organization","name":"EricLog","logo":{"@type":"ImageObject","url":"https://eric.swiftzer.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://eric.swiftzer.net/ accesskey=h title="EricLog (Alt + H)">EricLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://eric.swiftzer.net/fonts/ title=Fonts><span>Fonts</span></a></li><li><a href=https://eric.swiftzer.net/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://eric.swiftzer.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://eric.swiftzer.net/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://eric.swiftzer.net/>首頁</a>&nbsp;»&nbsp;<a href=https://eric.swiftzer.net/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">AndroidX Navigation component for Jetpack Compose type safety</h1><div class=post-meta><span title='2024-08-18 22:00:00 +0800 +0800'>August 18, 2024</span></div></header><div class=post-content><p>AndroidX Navigation component 是 Google 推出的 <a href="https://www.youtube.com/watch?v=2k8x8V77CrU">single <code>Activity</code> app</a> navigation library。本身是用 <code>Fragment</code> 來做每一頁的內容，然後再用新的 Android resource type——navigation 來定義 navigation graph（即是聲明一個 navigation graph 內有什麼 <code>Fragment</code>、打開 <code>Fragment</code> 時要什麼參數和各 <code>Fragment</code> 之間如何導覽的 XML 檔案）。如果加上 <a href=https://developer.android.com/guide/navigation/use-graph/safe-args>Safe Args</a> Gradle plugin 的話就會按 navigation graph XML 檔案生成那些 Java code 去讓你在 <code>Fragment</code> 內轉頁時調用，那就不會怕轉頁時漏了幾個參數沒有傳到，因為漏了的話就不能成功 compile。</p><h2 id=navigation-component-for-compose-的-navigation-方式>Navigation component for Compose 的 navigation 方式<a hidden class=anchor aria-hidden=true href=#navigation-component-for-compose-的-navigation-方式>#</a></h2><p>AndroidX Navigation 有推出了 Compose 版，其實核心都是沿用原本處理 <code>Fragment</code> navigation 的那些 code。但每頁的「代號」由 Android resource ID 改為網址式的 string 表示（叫做 route）。轉頁在 AndroidX Navigation Compose 的理解就是按網址找到對應的 composable function 去 call 然後在網址抽取打開該頁要用到的參數。用法大概就是這樣：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>composable</span><span class=p>(</span><span class=s2>&#34;shop/{shopId}?promoCode={promoCode}&#34;</span><span class=p>)</span> <span class=p>{</span> <span class=n>backStackEntry</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>shopId</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span> <span class=p>=</span> <span class=n>backStackEntry</span><span class=p>.</span><span class=n>arguments</span><span class=o>?.</span><span class=n>getString</span><span class=p>(</span><span class=s2>&#34;shopId&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>promoCode</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span> <span class=p>=</span> <span class=n>backStackEntry</span><span class=p>.</span><span class=n>arguments</span><span class=o>?.</span><span class=n>getString</span><span class=p>(</span><span class=s2>&#34;promoCode&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 該頁顯示的內容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Column</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Text</span><span class=p>(</span><span class=n>shopId</span><span class=p>.</span><span class=n>orEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>Text</span><span class=p>(</span><span class=n>promoCode</span><span class=p>.</span><span class=n>orEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以見到 <code>shop/{shopId}?showPromo={showPromo}</code> 就是該頁面的「代號」，而 <code>shopId</code> 是必需而 <code>showPromo</code> 是可選。要打開該頁的話就要用 <code>navController.navigate</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>navController</span><span class=p>.</span><span class=n>navigate</span><span class=p>(</span><span class=s2>&#34;shop/abc123?promoCode=foo&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>如果要傳更多參數就用 <code>/</code> （必需參數）和 <code>&</code> （可選參數）串接起來。這個網址單純就是為了表達不同的 route 和要傳遞的參數，跟 RESTful 沒有關係。</p><p>轉用網址來代表頁面的好處是方便 multiplatform。因為 resource ID 和 <code>Parcelable</code> 是 Android 才有（<code>Fragment</code> 版 AndroidX Navigation 是可以傳 <code>Parcelable</code> 參數），加上把參數塞到網址就可以很簡單地處理到 deep link。但對 Android 開發者而言是不太習慣，尤其是沒有簡單直接方法傳 <code>Parcelable</code> 參數和 <a href=https://developer.android.com/guide/fragments/communicate#fragment-result>Fragment Result API</a> 功能。可能因為 Google 的目標是想把 AndroidX Navigation 在 web app 都能用所以就把這些原本 <code>Fragment</code> 版有的東西都收起不做，然後直接在文檔寫不建議傳複雜 object，應該要傳 object 的 ID 然後再從 database 之類的地方拿 data，因為怕會在 <code>Activity.onSaveInstanceState</code> 塞爆。我覺得防止塞爆是合理，因為要考慮到 app 放在 background 後被 system kill app 然後 user 再從 recents 開 app 需要還原 kill app 前的狀態（雖然很多 Android developer 不去管這個問題，然後以為現在的裝置有很多 RAM 不會輪到自己的 app 被 kill，被 kill 之後重開 app 還原不了先前的狀態就爛掉）。但如果只是傳一些簡單的 object 要動用到 database/file system 開一個檔案又太勞師動眾。（下面會示範如何傳 <code>Parcelable</code> 參數）</p><p>如果想了解更多 Compose 的 Navigation component 使用方式可以查閱 2022 年寫的「<a href=https://eric.swiftzer.net/2022/07/jetpack-compose-navigation-component-sub-graph/>Jetpack Compose Navigation component sub-graph</a>」一文。</p><h2 id=type-safety-的-navigation-方式>Type safety 的 navigation 方式<a hidden class=anchor aria-hidden=true href=#type-safety-的-navigation-方式>#</a></h2><p>在 AndroidX Navigation 2.8.0 開始（目前是 beta）Compose Navigation 可以改用相對比較 type safety 的方法定義 route。其實之前已經有其他人用 <a href=https://github.com/google/ksp>Kotlin Symbol Processing (KSP)</a> 去生成 Kotlin code 去令 Compose Navigation 做到 type safety 的效果（生成那串網址、從 back stack entry 拿到參數的部分），但 Google 就不用 KSP 而是借用 <a href=https://github.com/Kotlin/kotlinx.serialization>Kotlin Serialization</a> Gradle plugin 生成的 <code>$serializer</code> class 來做到同樣效果（其實單純做 navigation route 是不用再加 <a href=https://github.com/Kotlin/kotlinx.serialization/blob/master/formats/README.md>JSON/ProtoBuf 之類的 artifact</a>）。我們會以下面那個 data class 做例子。這個 data class 有兩個 property，就是那個 route 的兩個參數。如果沒有 default value 就是必需，相反就是可選參數。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Serializable</span>
</span></span><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>StationDetailDestination</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>id</span><span class=p>:</span> <span class=n>Int</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=p>-</span><span class=m>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>lrlStopId</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=p>-</span><span class=m>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>如果這個頁面沒有參數要傳就改用 <code>object</code>/<code>data object</code> 再配搭 <code>@Serializable</code>。</p><p>之後 <code>composable</code> 的寫法改為傳 type 而不再傳 <code>route</code> 和 <code>arguments</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>composable</span><span class=p>&lt;</span><span class=n>StationDetailDestination</span><span class=p>&gt;(</span>
</span></span><span class=line><span class=cl>    <span class=n>deepLinks</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>navDeepLink</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>uriPattern</span> <span class=p>=</span> <span class=s2>&#34;https://lrnt.mtr.com.hk/moblink/?station_id={lrlStopId}&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 內容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>之前的寫法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>composable</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>route</span> <span class=p>=</span> <span class=s2>&#34;stationDetail/{id}&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>arguments</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>navArgument</span><span class=p>(</span><span class=s2>&#34;id&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>type</span> <span class=p>=</span> <span class=nc>NavType</span><span class=p>.</span><span class=n>IntType</span>
</span></span><span class=line><span class=cl>            <span class=n>defaultValue</span> <span class=p>=</span> <span class=p>-</span><span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=n>navArgument</span><span class=p>(</span><span class=s2>&#34;lrlStopId&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>type</span> <span class=p>=</span> <span class=nc>NavType</span><span class=p>.</span><span class=n>IntType</span>
</span></span><span class=line><span class=cl>            <span class=n>defaultValue</span> <span class=p>=</span> <span class=p>-</span><span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>deepLinks</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 略
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 內容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>新寫法不用再傳 <code>route</code> 和 <code>arguments</code> 是因為 Navigation component 改為讀取 Kotlin Serialization Gradle plugin 生成的 code。當 class 被加了 <code>@Serializable</code> 後，Kotlin Serialization Gradle plugin 會生成 <code>$serializer</code> class。把 <code>StationDetailDestination</code> 的 JVM bytecode decompile 後會找到這段內容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>PluginGeneratedSerialDescriptor</span><span class=w> </span><span class=n>var0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>PluginGeneratedSerialDescriptor</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;net.swiftzer.metroride.app.station.detail.StationDetailDestination&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>(</span><span class=n>GeneratedSerializer</span><span class=p>)</span><span class=w> </span><span class=n>INSTANCE</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>var0</span><span class=p>.</span><span class=na>addElement</span><span class=p>(</span><span class=s>&#34;id&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>var0</span><span class=p>.</span><span class=na>addElement</span><span class=p>(</span><span class=s>&#34;lrlStopId&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>descriptor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>var0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>$stable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>8</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如果我們 call <code>StationDetailDestination.serializer().descriptor</code> 的話可以找回那個 data class 的名稱和有什麼 property：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>descriptor</span> <span class=p>=</span> <span class=nc>StationDetailDestination</span><span class=p>.</span><span class=n>serializer</span><span class=p>().</span><span class=n>descriptor</span>
</span></span><span class=line><span class=cl><span class=n>println</span><span class=p>(</span><span class=n>descriptor</span><span class=p>.</span><span class=n>serialName</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=k>in</span> <span class=m>0</span> <span class=n>until</span> <span class=n>descriptor</span><span class=p>.</span><span class=n>elementsCount</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>${descriptor.getElementName(i)}</span><span class=s2>, </span><span class=si>${descriptor.getElementDescriptor(i).kind}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以下是 output：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>net.swiftzer.metroride.app.station.detail.StationDetailDestination
</span></span><span class=line><span class=cl>id, INT
</span></span><span class=line><span class=cl>lrlStopId, INT
</span></span></code></pre></div><p>所以 Navigation component 就能憑以上的方法生成出以往要人手寫的 <code>route</code> 和 <code>arguments</code>（對，都是沿用之前以網址形式做 navigation，只是你不會直接看到那個網址 route）。</p><p>要打開剛才那頁就這樣寫：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>navController</span><span class=p>.</span><span class=n>navigate</span><span class=p>(</span><span class=n>StationDetailDestination</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=m>123</span><span class=p>))</span>
</span></span></code></pre></div><p>以上的 <code>navigate</code> 會生成出這樣的 deep link 網址：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>android-app://androidx.navigation/net.swiftzer.metroride.app.station.detail.StationDetailDestination?id=123&amp;lrlStopId=-1
</span></span></code></pre></div><p>Route 名前面那部分就是 data class/object 的全名。Deep link 前面那段 <code>android-app://androidx.navigation/</code> 就是 Navigation component 專屬的 deep link 前綴。</p><p>至於如何讀取傳入 route 的參數？Navigation component 提供了 <code>toRoute</code> function 來讓你取回填好參數的 object。</p><p>以下是 <code>NavBackStackEntry</code> 版：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>composable</span><span class=p>&lt;</span><span class=n>StationDetailDestination</span><span class=p>&gt;(</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span> <span class=p>{</span> <span class=n>backStackEntry</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>args</span><span class=p>:</span> <span class=n>StationDetailDestination</span> <span class=p>=</span> <span class=n>backStackEntry</span><span class=p>.</span><span class=n>toRoute</span><span class=p>&lt;</span><span class=n>StationDetailDestination</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>args</span><span class=p>.</span><span class=n>id</span><span class=p>)</span> <span class=c1>// Int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>以下是 <code>SavedStateHandle</code> 版：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@HiltViewModel</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>StationDetailViewModel</span> <span class=nd>@Inject</span> <span class=k>constructor</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>savedStateHandle</span><span class=p>:</span> <span class=n>SavedStateHandle</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>:</span> <span class=n>ViewModel</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>val</span> <span class=py>args</span><span class=p>:</span> <span class=n>StationDetailDestination</span> <span class=p>=</span> <span class=n>savedStateHandle</span><span class=p>.</span><span class=n>toRoute</span><span class=p>&lt;</span><span class=n>StationDetailDestination</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>    <span class=k>init</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=n>args</span><span class=p>.</span><span class=n>id</span><span class=p>)</span> <span class=c1>// Int
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>而 sub-graph 都是同樣做法，不再傳 string：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Serializable</span>
</span></span><span class=line><span class=cl><span class=k>data</span> <span class=k>object</span> <span class=nc>StationGraph</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Serializable</span>
</span></span><span class=line><span class=cl><span class=k>data</span> <span class=k>object</span> <span class=nc>StationListDestination</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>navigation</span><span class=p>&lt;</span><span class=n>StationGraph</span><span class=p>&gt;(</span><span class=n>startDestination</span> <span class=p>=</span> <span class=n>StationListDestination</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>composable</span><span class=p>&lt;</span><span class=n>StationListDestination</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 略
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=parcelable><code>Parcelable</code><a hidden class=anchor aria-hidden=true href=#parcelable>#</a></h3><p>要在 Navigation component Compose 傳 <code>Parcelable</code> 的話是比較麻煩，即使有了 type safety 寫法都沒有用，仍然要手寫一段 code 才能做到。</p><p>下面示範了要傳遞一個 <code>Reason</code> enum 到 <code>ScanErrorDestination</code> 的寫法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Parcelize</span>
</span></span><span class=line><span class=cl><span class=nd>@Serializable</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>Reason</span> <span class=p>:</span> <span class=n>Parcelable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>UnsupportedCard</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TagLost</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Serializable</span>
</span></span><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>ScanErrorDestination</span><span class=p>(</span><span class=k>val</span> <span class=py>reason</span><span class=p>:</span> <span class=n>Reason</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>NavGraphBuilder</span><span class=p>.</span><span class=n>scanErrorScreen</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>navigateUp</span><span class=p>:</span> <span class=p>()</span> <span class=o>-&gt;</span> <span class=n>Unit</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>composable</span><span class=p>&lt;</span><span class=n>ScanErrorDestination</span><span class=p>&gt;(</span>
</span></span><span class=line><span class=cl>        <span class=n>typeMap</span> <span class=p>=</span> <span class=n>ScanErrorScreenMap</span><span class=p>,</span> <span class=c1>// 之後會有這段 code
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>)</span> <span class=p>{</span> <span class=n>backStackEntry</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>args</span> <span class=p>=</span> <span class=n>backStackEntry</span><span class=p>.</span><span class=n>toRoute</span><span class=p>&lt;</span><span class=n>ScanErrorDestination</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>        <span class=n>ScanErrorScreen</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>reason</span> <span class=p>=</span> <span class=n>args</span><span class=p>.</span><span class=n>reason</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>modifier</span> <span class=p>=</span> <span class=nc>Modifier</span><span class=p>.</span><span class=n>fillMaxSize</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=n>navigateUp</span> <span class=p>=</span> <span class=n>navigateUp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面 <code>composable</code> 多了一個 <code>typeMap</code> 參數，這個就是用來處理 <code>Parcelable</code> 的部分。以下是 <code>ScanErrorScreenMap</code> 的內容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>NavigationProtoBuf</span> <span class=p>=</span> <span class=n>ProtoBuf</span> <span class=p>{</span> <span class=n>encodeDefaults</span> <span class=p>=</span> <span class=k>false</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>ReasonType</span> <span class=p>=</span> <span class=k>object</span> <span class=err>: </span><span class=nc>NavType</span><span class=p>&lt;</span><span class=n>Reason</span><span class=p>&gt;(</span><span class=n>isNullableAllowed</span> <span class=p>=</span> <span class=k>false</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>get</span><span class=p>(</span><span class=n>bundle</span><span class=p>:</span> <span class=n>Bundle</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=n>String</span><span class=p>):</span> <span class=n>Reason</span><span class=p>?</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>        <span class=nc>BundleCompat</span><span class=p>.</span><span class=n>getParcelable</span><span class=p>(</span><span class=n>bundle</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>Reason</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>put</span><span class=p>(</span><span class=n>bundle</span><span class=p>:</span> <span class=n>Bundle</span><span class=p>,</span> <span class=n>key</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=k>value</span><span class=p>:</span> <span class=n>Reason</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>bundle</span><span class=p>.</span><span class=n>putParcelable</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=k>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>serializeAsValue</span><span class=p>(</span><span class=k>value</span><span class=p>:</span> <span class=n>Reason</span><span class=p>):</span> <span class=n>String</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>        <span class=nc>NavigationProtoBuf</span><span class=p>.</span><span class=n>encodeToHexString</span><span class=p>(</span><span class=k>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>parseValue</span><span class=p>(</span><span class=k>value</span><span class=p>:</span> <span class=n>String</span><span class=p>):</span> <span class=n>Reason</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>        <span class=nc>NavigationProtoBuf</span><span class=p>.</span><span class=n>decodeFromHexString</span><span class=p>&lt;</span><span class=n>Reason</span><span class=p>&gt;(</span><span class=k>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>ScanErrorScreenMap</span> <span class=p>=</span> <span class=n>mapOf</span><span class=p>(</span><span class=n>typeOf</span><span class=p>&lt;</span><span class=n>Reason</span><span class=p>&gt;()</span> <span class=n>to</span> <span class=n>ReasonType</span><span class=p>)</span>
</span></span></code></pre></div><p><code>ScanErrorScreenMap</code> 就是用來定義 <code>ScanErrorDestination</code> 內的 property 如果有非 Navigation component 直接支援的 type 時要用對應的 <code>NavType</code> 來做 serialization/deserialization。<code>NavType</code> 簡單來講就是寫 serialization/deserialization 成 <code>Parcelable</code> 和 <code>String</code> 的實際操作部分。</p><p>先講 <code>Parcelable</code>，它就是平時轉頁時會用的 serialization 形式，對應的 function 是 <code>get</code> 和 <code>put</code>。只要在那個 enum 加上 <code>@Parcelize</code> 和 implement <code>Parcelable</code> 然後再 call 對應的 <code>Bundle</code> function 就做到。</p><p>另外兩個 function <code>serializeAsValue</code> 和 <code>parseValue</code> 是要把那個 enum 轉成 string 形式，它是對應 deep link（估計亦是日後支援 multiplatform 的處理方法，因為 <code>Parcelable</code> 是 Android 獨有的東西）。我就把那個 enum 用 Kotlin Serialization 轉成 ProtoBuf 十六進制 string 表示，你亦可以用 JSON 之類，但記得要做 URI encode/decode。</p><p>以前例子是傳 enum，其實大可傳 enum value 的 <code>ordinal</code>，這樣就不用寫那麼多 code。但如果是 data class 的話都是要這樣寫。</p><p>另外，如果在 <code>ViewModel</code> 內想透過 <code>SavedStateHandle</code> 獲取參數的話，要在 <code>SavedStateHandle.toRoute</code> 補回 <code>typeMap</code> 參數。<code>NavBackStackEntry.toRoute</code> 不用是因為 <code>NavBackStackEntry</code> 能找到 <code>typeMap</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>private</span> <span class=k>val</span> <span class=py>args</span> <span class=p>=</span> <span class=n>savedStateHandle</span><span class=p>.</span><span class=n>toRoute</span><span class=p>&lt;</span><span class=n>ScanErrorDestination</span><span class=p>&gt;(</span>
</span></span><span class=line><span class=cl>    <span class=n>typeMap</span> <span class=p>=</span> <span class=n>ScanErrorScreenMap</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><h3 id=analytics>Analytics<a hidden class=anchor aria-hidden=true href=#analytics>#</a></h3><p>如果要做 screen view 式的 event tracking 而又不想逐頁加 code，可以 collect <code>NavHostController.currentBackStackEntryFlow</code> 來得知轉頁並在這個時候做 event tracking。下面是用 Firebase Analytics 做例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>LaunchedEffect</span><span class=p>(</span><span class=n>navController</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>navController</span><span class=p>.</span><span class=n>currentBackStackEntryFlow</span><span class=p>.</span><span class=n>collectLatest</span> <span class=p>{</span> <span class=n>backStackEntry</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>backStackEntry</span><span class=p>.</span><span class=n>destination</span><span class=p>.</span><span class=n>route</span><span class=o>?.</span><span class=n>let</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nc>Firebase</span><span class=p>.</span><span class=n>analytics</span><span class=p>.</span><span class=n>logEvent</span><span class=p>(</span><span class=nc>FirebaseAnalytics</span><span class=p>.</span><span class=nc>Event</span><span class=p>.</span><span class=n>SCREEN_VIEW</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>param</span><span class=p>(</span><span class=nc>FirebaseAnalytics</span><span class=p>.</span><span class=nc>Param</span><span class=p>.</span><span class=n>SCREEN_CLASS</span><span class=p>,</span> <span class=k>it</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果用上面那個例子的話，<code>backStackEntry.destination.route</code> 其實就是 <code>net.swiftzer.metroride.app.station.detail.StationDetailDestination?id={id}&amp;lrlStopId={lrlStopId}</code>，不會有參數的值。</p><h3 id=是否完全-type-safefy>是否完全 type safefy？<a hidden class=anchor aria-hidden=true href=#是否完全-type-safefy>#</a></h3><p>其實上面的 code 都示範了 deep link 的話仍然是要人手寫，連同 Android manifest 的 deep link <code>&lt;intent-filter></code>都要自己寫，所以在 compile 時不能察覺寫錯（如果用 XML 版的話是有<a href=https://developer.android.com/guide/navigation/design/deep-link#implicit>半自動方法</a>生成 <code>&lt;intent-filter></code>）。所以 type safety 只是針對之前手寫 route 要聲明參數和讀取參數的部分而已。總體效果不如以前 XML 般，有不少地方仍要手寫 code 而且不是 compile 時檢查，例如 deep link 和 <code>NavType</code> adapter。</p><h2 id=安全問題>安全問題<a hidden class=anchor aria-hidden=true href=#安全問題>#</a></h2><p>今天逛 Reddit 發現了一篇名為「<a href=https://www.reddit.com/r/mAndroidDev/comments/1etw0t0/russian_hackers_destroy_jetpack_navigation_from/>Russian hackers destroy Jetpack Navigation from its very core, turning best practice into security vulnerability in the blink of an eye</a>」的文章，內容是連結到 <a href=https://swarm.ptsecurity.com/android-jetpack-navigation-go-even-deeper/>Android Jetpack Navigation: Go Even Deeper</a>。大意是如果你的 app 用了 AndroidX Navigation component for Compose 的話其實是可以讓人進入 <code>NavHost</code> 內任意一頁。</p><p>按文章內容所描述，進入任意一頁的方法是找出放了 <code>NavHost</code> 的那個 <code>Activity</code>，然後用 <code>Intent</code> 開它，開的時候要附帶 <code>data</code> <code>Uri</code>，<code>data</code> 內容就是 Navigation component 自動生成的 route（即是 <code>android-app://androidx.navigation/</code> 開首的網址）。其實不用另外做另一個 app 去 call <code>Intent.startActivity</code>，直接用 <a href=https://developer.android.com/tools/adb>Android Debug Bridge (adb)</a> 都可以：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>adb shell am start -W -a android.intent.action.VIEW -d <span class=s2>&#34;android-app://androidx.navigation/net.swiftzer.metroride.app.setting.SettingsDestination&#34;</span> net.swiftzer.metroride/net.swiftzer.metroride.app.entrypoint.MainActivity
</span></span></code></pre></div><p>這樣就可以直接開到 <a href="https://play.google.com/store/apps/details?id=net.swiftzer.metroride">MetroRide</a> 的設定頁。相信這對需要寫 end-to-end test 的人是個好消息，是一個 feature 而不是 bug。但如果你的 app 有部分頁面是需要登入後才能看的話這就比較尷尬（如果你不是在每頁都加登入檢查的話），因為這個方法可以繞過登入頁。</p><p>其實能夠打開到設定頁的原因是因為 <code>NavController</code> 會拿 <code>Activity.intent</code> 去檢查 graph 內有沒有頁面能對應到這個 deep link（<code>Activity.intent.data</code> 就是 deep link URI），而那些由 Navigation component 自行生成的 route（即是 <code>android-app://androidx.navigation/</code> 開首的網址）都會被 match 到。結果就能中門大開隨意進入 <code>NavHost</code> 內任何一頁。</p><figure><img loading=lazy src=nav-controller.png><figcaption>NavController 那一句 handleDeepLink</figcaption></figure><p>但似乎 Google 未修正這個問題，如果想馬上解決的話除了不用 Navigation component 之外就是把 <code>Intent.data</code> 清走。</p><p>在 <code>Activity</code> 的 <code>onCreate</code>（在 <code>setContent</code> 前）加入這個 <code>if</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>intent</span><span class=p>.</span><span class=k>data</span><span class=o>?.</span><span class=n>scheme</span> <span class=o>==</span> <span class=s2>&#34;android-app&#34;</span> <span class=o>&amp;&amp;</span> <span class=n>intent</span><span class=p>.</span><span class=k>data</span><span class=o>?.</span><span class=n>authority</span> <span class=o>==</span> <span class=s2>&#34;androidx.navigation&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>intent</span><span class=p>.</span><span class=k>data</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果 <code>Activity</code> 本身有設定 launch mode 是 <code>singleTop</code> 的話，亦應在 <code>onNewIntent</code> 刪走 <code>Intent.data</code>。</p><p>這篇文章其實有示範到其中一頁有個 <code>WebView</code> 而 <code>WebView</code> 載入的網址是從開那頁的參數提供並且那個 <code>WebView</code> 會在 request header 加入 token，結果透過這個方法就能拿到 token。這個其實應該在每次加入 token 前就要檢查一次 request URL 是不是指定的 URL 才加入 token 的 request header。如果想加強 JavaScript 與 native app 雙向溝通安全性的話可以參考 <a href=https://eric.swiftzer.net/2024/02/android-webview/>Android WebView 筆記</a>。</p><h2 id=結語>結語<a hidden class=anchor aria-hidden=true href=#結語>#</a></h2><p>我覺得很多 Android/iOS developer 在做 navigation 時沒有像那些 backend framework 處理 request 的思維。一般那些 backend framework 在處理 request/response 時都會經過一些 <a href=https://laravel.com/docs/11.x/middleware>middleware</a>，例如你可以定義一個 middleware 用來檢查用戶是否已登入，然後把它套在需要登入後才能進入的 route。這個 middleware 的大概內容是如果沒有登入就重定向到登入頁，然後直接 output response，不用再交去下一個 middleware 或者是該 route 對應的 controller。這其實跟 OkHttp 的 <a href=https://square.github.io/okhttp/features/interceptors/>interceptor</a> 相似。背後的 design pattern 是 <a href=https://refactoring.guru/design-patterns/chain-of-responsibility>Chain of Responsibility</a>，是 <a href=https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8>Gang of Four Design Patterns</a> 內的 pattern。</p><p>Google 將登入後才能進入否則重定向稱為 <a href=https://developer.android.com/guide/navigation/use-graph/conditional>conditional navigation</a>。它建議先讓用戶進入受限頁面，然後再用 <code>Activity</code> 層級開一個 <code>UserViewModel</code>，入面決定用戶是否已登入。而在受限頁面的 <code>onViewCreated</code> 就 observe <code>UserViewModel</code> 外露的是否已登入 <code>LiveData</code>。當發現未登入就馬上重定向到登入頁（準碓來說是在在受限頁面上顯示登入頁，沒有清除 back stack）。正因為沒有清除 back stack，用戶可以在登入頁按返回鍵回到之前的受限頁面。為了防止不斷重定向，它在受限頁面的 <code>SavedStateHandle</code> 加了一個 boolean flag 表明用戶是否成功登入，然後在受限頁面檢查那個 boolean flag 防止不斷在兩頁之間重定向。當然，今時今日不會有人這樣寫，因為兩個 <code>ViewModel</code> 之間通訊是很麻煩的事。通常都是用 dependency injection graph 加上一個能共用 instance 的 class 然後在入面放那些是否已登入的 <code>Flow</code>/<code>LiveData</code>/<code>Observable</code>。但 Google 這個提議最大問題是當頁面一多就很難 scale，因為它要求每頁都要加檢查的 code。</p><p>如果我們沿用 AndroidX Navigation component 又想做到類似 middleware 的效果，大概就是弄一個 suspending function 包起 <code>navController.navigate</code>，在那個 suspending function 內檢查要 navigate 的 route 有沒有 middleware 要執行，有的話就逐個執行。如果最終確認是可以直接進入目標頁面那就可以執行 <code>navController.navigate</code>。如果是要重定向的話就要為重定向頁做同樣的 middleware 執行動作，直到找到最終目的地為止。而用 suspending function 的原因是那些 middleware 可能需要做 I/O 動作，不像 <code>navController.navigate</code> 可以馬上完成。而 <code>NavHost</code> 外面要加一個載入畫面，當執行 middleware 時就蓋在 <code>NavHost</code> 上面不能讓用戶按到畫面其他地方。這樣就不用每一頁都要再檢查一次用戶是否已登入，因為在進入前已經被 middleware 檢查過。</p><p>很多 navigation library 偏向是補強 AndroidX Navigation component 欠缺生成 boilerplat code 的功能、或者令整個 app 變得更 MVI。反而中國出品的 navigation library 會做這類接近 middleware 的東西，但不知道有沒有考慮非同步的問題。它們甚至能做到由 backend 控制 navigation 的目的地（例如因應 A/B testing、feature flag 的值在 navigation 時開啟不同頁面）。</p><h2 id=參考>參考<a hidden class=anchor aria-hidden=true href=#參考>#</a></h2><ul><li><a href=https://medium.com/androiddevelopers/navigation-compose-meet-type-safety-e081fb3cf2f8>Navigation Compose meet Type Safety</a></li><li><a href="https://www.youtube.com/watch?v=AIC_OFQ1r3k">Type-Safe Navigation with the OFFICIAL Compose Navigation Library</a></li><li><a href=https://swarm.ptsecurity.com/android-jetpack-navigation-go-even-deeper/>Android Jetpack Navigation: Go Even Deeper</a></li><li><a href=https://therouter.cn/>TheRouter</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://eric.swiftzer.net/tags/android/>Android</a></li></ul><nav class=paginav><a class=next href=https://eric.swiftzer.net/2024/06/firebase-cloud-messaging-legacy-api/><span class=title>下一頁 »</span><br><span>Firebase Cloud Messaging legacy API</span></a></nav></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//efilm.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://eric.swiftzer.net/>EricLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>